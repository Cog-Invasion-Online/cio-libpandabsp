/*
 * This file was generated by:
 * ..\..\..\cio-panda3d\built_x64\bin\interrogate -fnames -string -refcount -assert -python-native -S..\..\..\cio-panda3d\built_x64/include -S..\..\..\cio-panda3d\built_x64/include/parser-inc -I./ -srcdir ./ -oc networksystem_igate.cpp -od networksystem.in -module networksystem -library networksystem -Dvolatile= -DINTERROGATE -DCPPPARSER -DCIO -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall networksystem.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_networksystem.h"
#include "datagram.h"
#include "datagramIterator.h"
#include "netAddress.h"
#include "networksystem.h"
#include "pdeque.h"
#include "pointerTo.h"
#include "py_panda.h"
#include "referenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class NetworkMessage
 */
typedef NetworkMessage NetworkMessage_localtype;
Define_Module_Class(networksystem, NetworkMessage, NetworkMessage_localtype, NetworkMessage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetworkMessage = &Dtool_NetworkMessage;
static void Dtool_PyModuleClassInit_NetworkMessage(PyObject *module);

/**
 * Forward declarations for top-level class NetworkSystem
 */
typedef NetworkSystem NetworkSystem_localtype;
Define_Module_Class(networksystem, NetworkSystem, NetworkSystem_localtype, NetworkSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetworkSystem = &Dtool_NetworkSystem;
static void Dtool_PyModuleClassInit_NetworkSystem(PyObject *module);

/**
 * Forward declarations for top-level class NetworkCallbacks
 */
typedef NetworkCallbacks NetworkCallbacks_localtype;
Define_Module_Class(networksystem, NetworkCallbacks, NetworkCallbacks_localtype, NetworkCallbacks);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetworkCallbacks = &Dtool_NetworkCallbacks;
static void Dtool_PyModuleClassInit_NetworkCallbacks(PyObject *module);

/**
 * Forward declarations for top-level class NetworkConnectionInfo
 */
typedef NetworkConnectionInfo NetworkConnectionInfo_localtype;
Define_Module_Class(networksystem, NetworkConnectionInfo, NetworkConnectionInfo_localtype, NetworkConnectionInfo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetworkConnectionInfo = &Dtool_NetworkConnectionInfo;
static void Dtool_PyModuleClassInit_NetworkConnectionInfo(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"NetworkMessage", &Dtool_NetworkMessage},
  {"NetworkSystem", &Dtool_NetworkSystem},
  {"NetworkCallbacks", &Dtool_NetworkCallbacks},
  {"NetworkConnectionInfo", &Dtool_NetworkConnectionInfo},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"NetAddress", nullptr},
#define Dtool_Ptr_NetAddress (imports[0].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[1].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[2].type)
  {nullptr, nullptr},
};
#endif

// NetAddress
#ifndef LINK_ALL_STATIC
inline static NetAddress *Dtool_Coerce_NetAddress(PyObject *args, NetAddress &coerced) {
  nassertr(Dtool_Ptr_NetAddress != nullptr, nullptr);
  nassertr(Dtool_Ptr_NetAddress->_Dtool_Coerce != nullptr, nullptr);
  return ((NetAddress *(*)(PyObject *, NetAddress &))Dtool_Ptr_NetAddress->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_NetAddress;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetAddress = &Dtool_NetAddress;
extern NetAddress *Dtool_Coerce_NetAddress(PyObject *args, NetAddress &coerced);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class NetworkMessage
 */
/**
 * Python function wrapper for:
 * Datagram const &NetworkMessage::get_datagram(void)
 */
static PyObject *Dtool_NetworkMessage_get_datagram_2(PyObject *self, PyObject *) {
  NetworkMessage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkMessage, (void **)&local_this, "NetworkMessage.get_datagram")) {
    return nullptr;
  }
  // 1-Datagram const &NetworkMessage::get_datagram(void)
  Datagram const *return_value = &(((*local_this).get_datagram)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, false, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_NetworkMessage_get_datagram_2_comment =
  "C++ Interface:\n"
  "get_datagram(const NetworkMessage self)\n";
#else
static const char *Dtool_NetworkMessage_get_datagram_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DatagramIterator &NetworkMessage::get_datagram_iterator(void)
 */
static PyObject *Dtool_NetworkMessage_get_datagram_iterator_3(PyObject *self, PyObject *) {
  NetworkMessage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkMessage, (void **)&local_this, "NetworkMessage.get_datagram_iterator")) {
    return nullptr;
  }
  // 1-DatagramIterator &NetworkMessage::get_datagram_iterator(void)
  DatagramIterator *return_value = &(((*local_this).get_datagram_iterator)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramIterator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NetworkMessage_get_datagram_iterator_3_comment =
  "C++ Interface:\n"
  "get_datagram_iterator(const NetworkMessage self)\n";
#else
static const char *Dtool_NetworkMessage_get_datagram_iterator_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetworkConnectionHandle NetworkMessage::get_connection(void)
 */
static PyObject *Dtool_NetworkMessage_get_connection_4(PyObject *self, PyObject *) {
  NetworkMessage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkMessage, (void **)&local_this, "NetworkMessage.get_connection")) {
    return nullptr;
  }
  // 1-NetworkConnectionHandle NetworkMessage::get_connection(void)
  NetworkConnectionHandle return_value = ((*local_this).get_connection)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetworkMessage_get_connection_4_comment =
  "C++ Interface:\n"
  "get_connection(const NetworkMessage self)\n";
#else
static const char *Dtool_NetworkMessage_get_connection_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NetworkMessage::NetworkMessage(void) = default
 * inline NetworkMessage::NetworkMessage(NetworkMessage const &) = default
 */
static int Dtool_Init_NetworkMessage(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NetworkMessage() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline NetworkMessage::NetworkMessage(void) = default
      NetworkMessage *return_value = new NetworkMessage();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkMessage, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NetworkMessage::NetworkMessage(NetworkMessage const &) = default
      NetworkMessage const *arg_this = (NetworkMessage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetworkMessage, 0, "NetworkMessage.NetworkMessage", true, true);
      if (arg_this != nullptr) {
        NetworkMessage *return_value = new NetworkMessage(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkMessage, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetworkMessage() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetworkMessage()\n"
      "NetworkMessage(const NetworkMessage param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NetworkMessage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetworkMessage) {
    printf("NetworkMessage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetworkMessage *local_this = (NetworkMessage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetworkMessage) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetworkMessage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetworkMessage) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NetworkSystem
 */
/**
 * Python function wrapper for:
 * NetworkConnectionHandle NetworkSystem::connect_by_IP_address(NetAddress const &addr)
 */
static PyObject *Dtool_NetworkSystem_connect_by_IP_address_10(PyObject *self, PyObject *arg) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.connect_by_IP_address")) {
    return nullptr;
  }
  // 1-NetworkConnectionHandle NetworkSystem::connect_by_IP_address(NetAddress const &addr)
  NetAddress arg_local;
  NetAddress const *arg_this = Dtool_Coerce_NetAddress(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NetworkSystem.connect_by_IP_address", "NetAddress");
  }
  NetworkConnectionHandle return_value = ((*local_this).connect_by_IP_address)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "connect_by_IP_address(const NetworkSystem self, const NetAddress addr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_connect_by_IP_address_10_comment =
  "C++ Interface:\n"
  "connect_by_IP_address(const NetworkSystem self, const NetAddress addr)\n";
#else
static const char *Dtool_NetworkSystem_connect_by_IP_address_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetworkSystem::get_connection_info(NetworkConnectionHandle hConn, NetworkConnectionInfo *pInfo)
 */
static PyObject *Dtool_NetworkSystem_get_connection_info_11(PyObject *self, PyObject *args, PyObject *kwds) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.get_connection_info")) {
    return nullptr;
  }
  // 1-bool NetworkSystem::get_connection_info(NetworkConnectionHandle hConn, NetworkConnectionInfo *pInfo)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"hConn", "pInfo", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:get_connection_info", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    NetworkConnectionInfo *param2_this = (NetworkConnectionInfo *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NetworkConnectionInfo, 2, "NetworkSystem.get_connection_info", false, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).get_connection_info)((NetworkConnectionHandle)param1, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_connection_info(const NetworkSystem self, int hConn, NetworkConnectionInfo pInfo)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_get_connection_info_11_comment =
  "C++ Interface:\n"
  "get_connection_info(const NetworkSystem self, int hConn, NetworkConnectionInfo pInfo)\n";
#else
static const char *Dtool_NetworkSystem_get_connection_info_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetworkSystem::send_datagram(NetworkConnectionHandle hConn, Datagram const &dg, NetworkSystem::NetworkSendFlags flags = ::NetworkSystem::NSF_reliable)
 */
static PyObject *Dtool_NetworkSystem_send_datagram_12(PyObject *self, PyObject *args, PyObject *kwds) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.send_datagram")) {
    return nullptr;
  }
  // 1-void NetworkSystem::send_datagram(NetworkConnectionHandle hConn, Datagram const &dg, NetworkSystem::NetworkSendFlags flags = ::NetworkSystem::NSF_reliable)
  unsigned long param1;
  PyObject *param2;
  int param3 = NetworkSystem::NSF_reliable;
  static const char *keyword_list[] = {"hConn", "dg", "flags", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO|i:send_datagram", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    Datagram param2_local;
    Datagram const *param2_this = Dtool_Coerce_Datagram(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "NetworkSystem.send_datagram", "Datagram");
    }
    ((*local_this).send_datagram)((NetworkConnectionHandle)param1, *param2_this, (NetworkSystem::NetworkSendFlags)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const NetworkSystem self, int hConn, const Datagram dg, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_send_datagram_12_comment =
  "C++ Interface:\n"
  "send_datagram(const NetworkSystem self, int hConn, const Datagram dg, int flags)\n";
#else
static const char *Dtool_NetworkSystem_send_datagram_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetworkSystem::close_connection(NetworkConnectionHandle hConn)
 */
static PyObject *Dtool_NetworkSystem_close_connection_13(PyObject *self, PyObject *arg) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.close_connection")) {
    return nullptr;
  }
  // 1-void NetworkSystem::close_connection(NetworkConnectionHandle hConn)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).close_connection)((NetworkConnectionHandle)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_connection(const NetworkSystem self, int hConn)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_close_connection_13_comment =
  "C++ Interface:\n"
  "close_connection(const NetworkSystem self, int hConn)\n";
#else
static const char *Dtool_NetworkSystem_close_connection_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetworkSystem::run_callbacks(NetworkCallbacks *pCallbacks)
 */
static PyObject *Dtool_NetworkSystem_run_callbacks_14(PyObject *self, PyObject *arg) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.run_callbacks")) {
    return nullptr;
  }
  // 1-void NetworkSystem::run_callbacks(NetworkCallbacks *pCallbacks)
  NetworkCallbacks *arg_this = (NetworkCallbacks *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetworkCallbacks, 1, "NetworkSystem.run_callbacks", false, true);
  if (arg_this != nullptr) {
    ((*local_this).run_callbacks)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "run_callbacks(const NetworkSystem self, NetworkCallbacks pCallbacks)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_run_callbacks_14_comment =
  "C++ Interface:\n"
  "run_callbacks(const NetworkSystem self, NetworkCallbacks pCallbacks)\n";
#else
static const char *Dtool_NetworkSystem_run_callbacks_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetworkSystem::accept_connection(NetworkConnectionHandle hConn)
 */
static PyObject *Dtool_NetworkSystem_accept_connection_15(PyObject *self, PyObject *arg) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.accept_connection")) {
    return nullptr;
  }
  // 1-bool NetworkSystem::accept_connection(NetworkConnectionHandle hConn)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).accept_connection)((NetworkConnectionHandle)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "accept_connection(const NetworkSystem self, int hConn)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_accept_connection_15_comment =
  "C++ Interface:\n"
  "accept_connection(const NetworkSystem self, int hConn)\n";
#else
static const char *Dtool_NetworkSystem_accept_connection_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetworkSystem::set_connection_poll_group(NetworkConnectionHandle hConn, NetworkPollGroupHandle hPollGroup)
 */
static PyObject *Dtool_NetworkSystem_set_connection_poll_group_16(PyObject *self, PyObject *args, PyObject *kwds) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.set_connection_poll_group")) {
    return nullptr;
  }
  // 1-bool NetworkSystem::set_connection_poll_group(NetworkConnectionHandle hConn, NetworkPollGroupHandle hPollGroup)
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"hConn", "hPollGroup", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:set_connection_poll_group", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    bool return_value = ((*local_this).set_connection_poll_group)((NetworkConnectionHandle)param1, (NetworkPollGroupHandle)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connection_poll_group(const NetworkSystem self, int hConn, int hPollGroup)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_set_connection_poll_group_16_comment =
  "C++ Interface:\n"
  "set_connection_poll_group(const NetworkSystem self, int hConn, int hPollGroup)\n";
#else
static const char *Dtool_NetworkSystem_set_connection_poll_group_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetworkSystem::receive_message_on_connection(NetworkConnectionHandle hConn, NetworkMessage &msg)
 */
static PyObject *Dtool_NetworkSystem_receive_message_on_connection_17(PyObject *self, PyObject *args, PyObject *kwds) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.receive_message_on_connection")) {
    return nullptr;
  }
  // 1-bool NetworkSystem::receive_message_on_connection(NetworkConnectionHandle hConn, NetworkMessage &msg)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"hConn", "msg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:receive_message_on_connection", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    NetworkMessage *param2_this = (NetworkMessage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NetworkMessage, 2, "NetworkSystem.receive_message_on_connection", false, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).receive_message_on_connection)((NetworkConnectionHandle)param1, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_message_on_connection(const NetworkSystem self, int hConn, NetworkMessage msg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_receive_message_on_connection_17_comment =
  "C++ Interface:\n"
  "receive_message_on_connection(const NetworkSystem self, int hConn, NetworkMessage msg)\n";
#else
static const char *Dtool_NetworkSystem_receive_message_on_connection_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetworkSystem::receive_message_on_poll_group(NetworkPollGroupHandle hPollGroup, NetworkMessage &msg)
 */
static PyObject *Dtool_NetworkSystem_receive_message_on_poll_group_18(PyObject *self, PyObject *args, PyObject *kwds) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.receive_message_on_poll_group")) {
    return nullptr;
  }
  // 1-bool NetworkSystem::receive_message_on_poll_group(NetworkPollGroupHandle hPollGroup, NetworkMessage &msg)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"hPollGroup", "msg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:receive_message_on_poll_group", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    NetworkMessage *param2_this = (NetworkMessage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NetworkMessage, 2, "NetworkSystem.receive_message_on_poll_group", false, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).receive_message_on_poll_group)((NetworkPollGroupHandle)param1, *param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_message_on_poll_group(const NetworkSystem self, int hPollGroup, NetworkMessage msg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_receive_message_on_poll_group_18_comment =
  "C++ Interface:\n"
  "receive_message_on_poll_group(const NetworkSystem self, int hPollGroup, NetworkMessage msg)\n";
#else
static const char *Dtool_NetworkSystem_receive_message_on_poll_group_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetworkPollGroupHandle NetworkSystem::create_poll_group(void)
 */
static PyObject *Dtool_NetworkSystem_create_poll_group_19(PyObject *self, PyObject *) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.create_poll_group")) {
    return nullptr;
  }
  // 1-NetworkPollGroupHandle NetworkSystem::create_poll_group(void)
  NetworkPollGroupHandle return_value = ((*local_this).create_poll_group)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_create_poll_group_19_comment =
  "C++ Interface:\n"
  "create_poll_group(const NetworkSystem self)\n";
#else
static const char *Dtool_NetworkSystem_create_poll_group_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetworkListenSocketHandle NetworkSystem::create_listen_socket(int port)
 */
static PyObject *Dtool_NetworkSystem_create_listen_socket_20(PyObject *self, PyObject *arg) {
  NetworkSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkSystem, (void **)&local_this, "NetworkSystem.create_listen_socket")) {
    return nullptr;
  }
  // 1-NetworkListenSocketHandle NetworkSystem::create_listen_socket(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NetworkListenSocketHandle return_value = ((*local_this).create_listen_socket)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_listen_socket(const NetworkSystem self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_create_listen_socket_20_comment =
  "C++ Interface:\n"
  "create_listen_socket(const NetworkSystem self, int port)\n";
#else
static const char *Dtool_NetworkSystem_create_listen_socket_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static NetworkSystem *NetworkSystem::get_global_ptr(void)
 */
static PyObject *Dtool_NetworkSystem_get_global_ptr_21(PyObject *, PyObject *) {
  // 1-static NetworkSystem *NetworkSystem::get_global_ptr(void)
  NetworkSystem *return_value = (NetworkSystem::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetworkSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NetworkSystem_get_global_ptr_21_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_NetworkSystem_get_global_ptr_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NetworkSystem::NetworkSystem(void) = default
 * inline NetworkSystem::NetworkSystem(NetworkSystem const &) = default
 */
static int Dtool_Init_NetworkSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NetworkSystem() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline NetworkSystem::NetworkSystem(void) = default
      NetworkSystem *return_value = new NetworkSystem();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkSystem, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NetworkSystem::NetworkSystem(NetworkSystem const &) = default
      NetworkSystem const *arg_this = (NetworkSystem *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetworkSystem, 0, "NetworkSystem.NetworkSystem", true, true);
      if (arg_this != nullptr) {
        NetworkSystem *return_value = new NetworkSystem(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkSystem, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetworkSystem() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetworkSystem()\n"
      "NetworkSystem(const NetworkSystem param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NetworkSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetworkSystem) {
    printf("NetworkSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetworkSystem *local_this = (NetworkSystem *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetworkSystem) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetworkSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetworkSystem) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NetworkCallbacks
 */
/**
 * Python function wrapper for:
 * void NetworkCallbacks::set_callback(PyObject *pPyCallback)
 */
static PyObject *Dtool_NetworkCallbacks_set_callback_30(PyObject *self, PyObject *arg) {
  NetworkCallbacks *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkCallbacks, (void **)&local_this, "NetworkCallbacks.set_callback")) {
    return nullptr;
  }
  // 1-void NetworkCallbacks::set_callback(PyObject *pPyCallback)
  ((*local_this).set_callback)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_callback(const NetworkCallbacks self, object pPyCallback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetworkCallbacks_set_callback_30_comment =
  "C++ Interface:\n"
  "set_callback(const NetworkCallbacks self, object pPyCallback)\n";
#else
static const char *Dtool_NetworkCallbacks_set_callback_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetworkCallbacks::NetworkCallbacks(void)
 * inline NetworkCallbacks::NetworkCallbacks(NetworkCallbacks const &) = default
 */
static int Dtool_Init_NetworkCallbacks(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NetworkCallbacks() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-NetworkCallbacks::NetworkCallbacks(void)
      NetworkCallbacks *return_value = new NetworkCallbacks();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkCallbacks, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NetworkCallbacks::NetworkCallbacks(NetworkCallbacks const &) = default
      NetworkCallbacks const *arg_this = (NetworkCallbacks *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetworkCallbacks, 0, "NetworkCallbacks.NetworkCallbacks", true, true);
      if (arg_this != nullptr) {
        NetworkCallbacks *return_value = new NetworkCallbacks(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkCallbacks, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetworkCallbacks() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetworkCallbacks()\n"
      "NetworkCallbacks(const NetworkCallbacks param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NetworkCallbacks(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetworkCallbacks) {
    printf("NetworkCallbacks ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetworkCallbacks *local_this = (NetworkCallbacks *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetworkCallbacks) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetworkCallbacks(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetworkCallbacks) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NetworkConnectionInfo
 */
static PyObject *Dtool_NetworkConnectionInfo_listenSocket_Getter(PyObject *self, void *) {
  const NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetworkConnectionInfo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-NetworkListenSocketHandle NetworkConnectionInfo::get_listenSocket(void) const
  NetworkListenSocketHandle return_value = ((const NetworkConnectionInfo*)local_this)->listenSocket;
  return Dtool_WrapValue(return_value);
}

static int Dtool_NetworkConnectionInfo_listenSocket_Setter(PyObject *self, PyObject *arg, void *) {
  NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkConnectionInfo, (void **)&local_this, "NetworkConnectionInfo.listenSocket")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete listenSocket attribute");
    return -1;
  }
  // 1-void NetworkConnectionInfo::set_listenSocket(NetworkListenSocketHandle value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %lu out of range for unsigned integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->listenSocket = (NetworkListenSocketHandle)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_listenSocket(const NetworkConnectionInfo self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_NetworkConnectionInfo_netAddress_Getter(PyObject *self, void *) {
  const NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetworkConnectionInfo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-NetAddress const &NetworkConnectionInfo::get_netAddress(void) const
  NetAddress const *return_value = &(((const NetworkConnectionInfo*)local_this)->netAddress);
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

static PyObject *Dtool_NetworkConnectionInfo_state_Getter(PyObject *self, void *) {
  const NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetworkConnectionInfo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-NetworkSystem::NetworkConnectionState NetworkConnectionInfo::get_state(void) const
  NetworkSystem::NetworkConnectionState return_value = ((const NetworkConnectionInfo*)local_this)->state;
  return Dtool_WrapValue(return_value);
}

static int Dtool_NetworkConnectionInfo_state_Setter(PyObject *self, PyObject *arg, void *) {
  NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkConnectionInfo, (void **)&local_this, "NetworkConnectionInfo.state")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete state attribute");
    return -1;
  }
  // 1-void NetworkConnectionInfo::set_state(NetworkSystem::NetworkConnectionState value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->state = (NetworkSystem::NetworkConnectionState)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_state(const NetworkConnectionInfo self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_NetworkConnectionInfo_endReason_Getter(PyObject *self, void *) {
  const NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetworkConnectionInfo, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int NetworkConnectionInfo::get_endReason(void) const
  int return_value = ((const NetworkConnectionInfo*)local_this)->endReason;
  return Dtool_WrapValue(return_value);
}

static int Dtool_NetworkConnectionInfo_endReason_Setter(PyObject *self, PyObject *arg, void *) {
  NetworkConnectionInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetworkConnectionInfo, (void **)&local_this, "NetworkConnectionInfo.endReason")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete endReason attribute");
    return -1;
  }
  // 1-void NetworkConnectionInfo::set_endReason(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->endReason = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_endReason(const NetworkConnectionInfo self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline NetworkConnectionInfo::NetworkConnectionInfo(void) = default
 * inline NetworkConnectionInfo::NetworkConnectionInfo(NetworkConnectionInfo const &) = default
 */
static int Dtool_Init_NetworkConnectionInfo(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NetworkConnectionInfo() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline NetworkConnectionInfo::NetworkConnectionInfo(void) = default
      NetworkConnectionInfo *return_value = new NetworkConnectionInfo();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkConnectionInfo, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline NetworkConnectionInfo::NetworkConnectionInfo(NetworkConnectionInfo const &) = default
      NetworkConnectionInfo const *arg_this = (NetworkConnectionInfo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetworkConnectionInfo, 0, "NetworkConnectionInfo.NetworkConnectionInfo", true, true);
      if (arg_this != nullptr) {
        NetworkConnectionInfo *return_value = new NetworkConnectionInfo(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetworkConnectionInfo, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetworkConnectionInfo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetworkConnectionInfo()\n"
      "NetworkConnectionInfo(const NetworkConnectionInfo param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NetworkConnectionInfo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetworkConnectionInfo) {
    printf("NetworkConnectionInfo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetworkConnectionInfo *local_this = (NetworkConnectionInfo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetworkConnectionInfo) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetworkConnectionInfo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetworkConnectionInfo) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for NetworkMessage (NetworkMessage)
 */
static PyMethodDef Dtool_Methods_NetworkMessage[] = {
  {"get_datagram", &Dtool_NetworkMessage_get_datagram_2, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_datagram_2_comment},
  {"getDatagram", &Dtool_NetworkMessage_get_datagram_2, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_datagram_2_comment},
  {"get_datagram_iterator", &Dtool_NetworkMessage_get_datagram_iterator_3, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_datagram_iterator_3_comment},
  {"getDatagramIterator", &Dtool_NetworkMessage_get_datagram_iterator_3, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_datagram_iterator_3_comment},
  {"get_connection", &Dtool_NetworkMessage_get_connection_4, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_connection_4_comment},
  {"getConnection", &Dtool_NetworkMessage_get_connection_4, METH_NOARGS, (const char *)Dtool_NetworkMessage_get_connection_4_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NetworkMessage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NetworkMessage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "networksystem.NetworkMessage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetworkMessage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NetworkMessage,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetworkMessage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetworkMessage,
    PyType_GenericAlloc,
    Dtool_new_NetworkMessage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetworkMessage,
  Dtool_UpcastInterface_NetworkMessage,
  Dtool_DowncastInterface_NetworkMessage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NetworkMessage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetworkMessage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NetworkMessage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetworkMessage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetworkMessage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetworkMessage);
  }
}

/**
 * Python method tables for NetworkSystem (NetworkSystem)
 */
static PyMethodDef Dtool_Methods_NetworkSystem[] = {
  {"connect_by_IP_address", &Dtool_NetworkSystem_connect_by_IP_address_10, METH_O, (const char *)Dtool_NetworkSystem_connect_by_IP_address_10_comment},
  {"connectByIPAddress", &Dtool_NetworkSystem_connect_by_IP_address_10, METH_O, (const char *)Dtool_NetworkSystem_connect_by_IP_address_10_comment},
  {"get_connection_info", (PyCFunction) &Dtool_NetworkSystem_get_connection_info_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_get_connection_info_11_comment},
  {"getConnectionInfo", (PyCFunction) &Dtool_NetworkSystem_get_connection_info_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_get_connection_info_11_comment},
  {"send_datagram", (PyCFunction) &Dtool_NetworkSystem_send_datagram_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_send_datagram_12_comment},
  {"sendDatagram", (PyCFunction) &Dtool_NetworkSystem_send_datagram_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_send_datagram_12_comment},
  {"close_connection", &Dtool_NetworkSystem_close_connection_13, METH_O, (const char *)Dtool_NetworkSystem_close_connection_13_comment},
  {"closeConnection", &Dtool_NetworkSystem_close_connection_13, METH_O, (const char *)Dtool_NetworkSystem_close_connection_13_comment},
  {"run_callbacks", &Dtool_NetworkSystem_run_callbacks_14, METH_O, (const char *)Dtool_NetworkSystem_run_callbacks_14_comment},
  {"runCallbacks", &Dtool_NetworkSystem_run_callbacks_14, METH_O, (const char *)Dtool_NetworkSystem_run_callbacks_14_comment},
  {"accept_connection", &Dtool_NetworkSystem_accept_connection_15, METH_O, (const char *)Dtool_NetworkSystem_accept_connection_15_comment},
  {"acceptConnection", &Dtool_NetworkSystem_accept_connection_15, METH_O, (const char *)Dtool_NetworkSystem_accept_connection_15_comment},
  {"set_connection_poll_group", (PyCFunction) &Dtool_NetworkSystem_set_connection_poll_group_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_set_connection_poll_group_16_comment},
  {"setConnectionPollGroup", (PyCFunction) &Dtool_NetworkSystem_set_connection_poll_group_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_set_connection_poll_group_16_comment},
  {"receive_message_on_connection", (PyCFunction) &Dtool_NetworkSystem_receive_message_on_connection_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_receive_message_on_connection_17_comment},
  {"receiveMessageOnConnection", (PyCFunction) &Dtool_NetworkSystem_receive_message_on_connection_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_receive_message_on_connection_17_comment},
  {"receive_message_on_poll_group", (PyCFunction) &Dtool_NetworkSystem_receive_message_on_poll_group_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_receive_message_on_poll_group_18_comment},
  {"receiveMessageOnPollGroup", (PyCFunction) &Dtool_NetworkSystem_receive_message_on_poll_group_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetworkSystem_receive_message_on_poll_group_18_comment},
  {"create_poll_group", &Dtool_NetworkSystem_create_poll_group_19, METH_NOARGS, (const char *)Dtool_NetworkSystem_create_poll_group_19_comment},
  {"createPollGroup", &Dtool_NetworkSystem_create_poll_group_19, METH_NOARGS, (const char *)Dtool_NetworkSystem_create_poll_group_19_comment},
  {"create_listen_socket", &Dtool_NetworkSystem_create_listen_socket_20, METH_O, (const char *)Dtool_NetworkSystem_create_listen_socket_20_comment},
  {"createListenSocket", &Dtool_NetworkSystem_create_listen_socket_20, METH_O, (const char *)Dtool_NetworkSystem_create_listen_socket_20_comment},
  {"get_global_ptr", &Dtool_NetworkSystem_get_global_ptr_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetworkSystem_get_global_ptr_21_comment},
  {"getGlobalPtr", &Dtool_NetworkSystem_get_global_ptr_21, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetworkSystem_get_global_ptr_21_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NetworkSystem = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NetworkSystem = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "networksystem.NetworkSystem",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetworkSystem,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NetworkSystem,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetworkSystem,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetworkSystem,
    PyType_GenericAlloc,
    Dtool_new_NetworkSystem,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetworkSystem,
  Dtool_UpcastInterface_NetworkSystem,
  Dtool_DowncastInterface_NetworkSystem,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NetworkSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetworkSystem._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(29);
    Dtool_NetworkSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum NetworkSystem::NetworkSendFlags;
    PyDict_SetItemString(dict, "NSF_unreliable", Dtool_WrapValue(NetworkSystem::NSF_unreliable));
    PyDict_SetItemString(dict, "NSFUnreliable", Dtool_WrapValue(NetworkSystem::NSF_unreliable));
    PyDict_SetItemString(dict, "NSF_no_nagle", Dtool_WrapValue(NetworkSystem::NSF_no_nagle));
    PyDict_SetItemString(dict, "NSFNoNagle", Dtool_WrapValue(NetworkSystem::NSF_no_nagle));
    PyDict_SetItemString(dict, "NSF_unreliable_no_nagle", Dtool_WrapValue(NetworkSystem::NSF_unreliable_no_nagle));
    PyDict_SetItemString(dict, "NSFUnreliableNoNagle", Dtool_WrapValue(NetworkSystem::NSF_unreliable_no_nagle));
    PyDict_SetItemString(dict, "NSF_no_delay", Dtool_WrapValue(NetworkSystem::NSF_no_delay));
    PyDict_SetItemString(dict, "NSFNoDelay", Dtool_WrapValue(NetworkSystem::NSF_no_delay));
    PyDict_SetItemString(dict, "NSF_unreliable_no_delay", Dtool_WrapValue(NetworkSystem::NSF_unreliable_no_delay));
    PyDict_SetItemString(dict, "NSFUnreliableNoDelay", Dtool_WrapValue(NetworkSystem::NSF_unreliable_no_delay));
    PyDict_SetItemString(dict, "NSF_reliable", Dtool_WrapValue(NetworkSystem::NSF_reliable));
    PyDict_SetItemString(dict, "NSFReliable", Dtool_WrapValue(NetworkSystem::NSF_reliable));
    PyDict_SetItemString(dict, "NSF_reliable_no_nagle", Dtool_WrapValue(NetworkSystem::NSF_reliable_no_nagle));
    PyDict_SetItemString(dict, "NSFReliableNoNagle", Dtool_WrapValue(NetworkSystem::NSF_reliable_no_nagle));
    PyDict_SetItemString(dict, "NSF_use_current_thread", Dtool_WrapValue(NetworkSystem::NSF_use_current_thread));
    PyDict_SetItemString(dict, "NSFUseCurrentThread", Dtool_WrapValue(NetworkSystem::NSF_use_current_thread));
    // enum NetworkSystem::NetworkConnectionState;
    PyDict_SetItemString(dict, "NCS_none", Dtool_WrapValue(NetworkSystem::NCS_none));
    PyDict_SetItemString(dict, "NCSNone", Dtool_WrapValue(NetworkSystem::NCS_none));
    PyDict_SetItemString(dict, "NCS_connecting", Dtool_WrapValue(NetworkSystem::NCS_connecting));
    PyDict_SetItemString(dict, "NCSConnecting", Dtool_WrapValue(NetworkSystem::NCS_connecting));
    PyDict_SetItemString(dict, "NCS_finding_route", Dtool_WrapValue(NetworkSystem::NCS_finding_route));
    PyDict_SetItemString(dict, "NCSFindingRoute", Dtool_WrapValue(NetworkSystem::NCS_finding_route));
    PyDict_SetItemString(dict, "NCS_connected", Dtool_WrapValue(NetworkSystem::NCS_connected));
    PyDict_SetItemString(dict, "NCSConnected", Dtool_WrapValue(NetworkSystem::NCS_connected));
    PyDict_SetItemString(dict, "NCS_closed_by_peer", Dtool_WrapValue(NetworkSystem::NCS_closed_by_peer));
    PyDict_SetItemString(dict, "NCSClosedByPeer", Dtool_WrapValue(NetworkSystem::NCS_closed_by_peer));
    PyDict_SetItemString(dict, "NCS_problem_detected_locally", Dtool_WrapValue(NetworkSystem::NCS_problem_detected_locally));
    PyDict_SetItemString(dict, "NCSProblemDetectedLocally", Dtool_WrapValue(NetworkSystem::NCS_problem_detected_locally));
    if (PyType_Ready((PyTypeObject *)&Dtool_NetworkSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetworkSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetworkSystem);
  }
}

/**
 * Python method tables for NetworkCallbacks (NetworkCallbacks)
 */
static PyMethodDef Dtool_Methods_NetworkCallbacks[] = {
  {"set_callback", &Dtool_NetworkCallbacks_set_callback_30, METH_O, (const char *)Dtool_NetworkCallbacks_set_callback_30_comment},
  {"setCallback", &Dtool_NetworkCallbacks_set_callback_30, METH_O, (const char *)Dtool_NetworkCallbacks_set_callback_30_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NetworkCallbacks = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NetworkCallbacks = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NetworkCallbacks = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NetworkCallbacks = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NetworkCallbacks = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NetworkCallbacks = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "networksystem.NetworkCallbacks",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetworkCallbacks,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NetworkCallbacks,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NetworkCallbacks,
    &Dtool_SequenceMethods_NetworkCallbacks,
    &Dtool_MappingMethods_NetworkCallbacks,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NetworkCallbacks,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetworkCallbacks,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetworkCallbacks,
    PyType_GenericAlloc,
    Dtool_new_NetworkCallbacks,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetworkCallbacks,
  Dtool_UpcastInterface_NetworkCallbacks,
  Dtool_DowncastInterface_NetworkCallbacks,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NetworkCallbacks(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetworkCallbacks._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NetworkCallbacks._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetworkCallbacks) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetworkCallbacks)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetworkCallbacks);
  }
}

/**
 * Python method tables for NetworkConnectionInfo (NetworkConnectionInfo)
 */
static PyMethodDef Dtool_Methods_NetworkConnectionInfo[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_NetworkConnectionInfo[] = {
  {(char *)"listenSocket", &Dtool_NetworkConnectionInfo_listenSocket_Getter, &Dtool_NetworkConnectionInfo_listenSocket_Setter, nullptr, nullptr},
  {(char *)"netAddress", &Dtool_NetworkConnectionInfo_netAddress_Getter, nullptr, nullptr, nullptr},
  {(char *)"state", &Dtool_NetworkConnectionInfo_state_Getter, &Dtool_NetworkConnectionInfo_state_Setter, nullptr, nullptr},
  {(char *)"endReason", &Dtool_NetworkConnectionInfo_endReason_Getter, &Dtool_NetworkConnectionInfo_endReason_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_NetworkConnectionInfo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NetworkConnectionInfo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "networksystem.NetworkConnectionInfo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetworkConnectionInfo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NetworkConnectionInfo,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetworkConnectionInfo,
    nullptr, // tp_members
    Dtool_Properties_NetworkConnectionInfo,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetworkConnectionInfo,
    PyType_GenericAlloc,
    Dtool_new_NetworkConnectionInfo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetworkConnectionInfo,
  Dtool_UpcastInterface_NetworkConnectionInfo,
  Dtool_DowncastInterface_NetworkConnectionInfo,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NetworkConnectionInfo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetworkConnectionInfo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NetworkConnectionInfo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetworkConnectionInfo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetworkConnectionInfo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetworkConnectionInfo);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_networksystem_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_networksystem_BuildInstants(PyObject *module) {
  (void) module;
  // NetworkMessage
  Dtool_PyModuleClassInit_NetworkMessage(module);
  PyModule_AddObject(module, "NetworkMessage", (PyObject *)&Dtool_NetworkMessage);
  // NetworkSystem
  Dtool_PyModuleClassInit_NetworkSystem(module);
  PyModule_AddObject(module, "NetworkSystem", (PyObject *)&Dtool_NetworkSystem);
  // NetworkCallbacks
  Dtool_PyModuleClassInit_NetworkCallbacks(module);
  PyModule_AddObject(module, "NetworkCallbacks", (PyObject *)&Dtool_NetworkCallbacks);
  // NetworkConnectionInfo
  Dtool_PyModuleClassInit_NetworkConnectionInfo(module);
  PyModule_AddObject(module, "NetworkConnectionInfo", (PyObject *)&Dtool_NetworkConnectionInfo);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef networksystem_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef networksystem_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1585470428,  /* file_identifier */
  "networksystem",  /* library_name */
  "XHsk",  /* library_hash_name */
  "networksystem",  /* module_name */
  "networksystem.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  102  /* next_index */
};

Configure(_in_configure_networksystem);
ConfigureFn(_in_configure_networksystem) {
  interrogate_request_module(&_in_module_def);
}

