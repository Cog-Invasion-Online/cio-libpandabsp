/*
 * This file was generated by:
 * ..\..\..\cio\cio-panda3d\built\bin\interrogate -fnames -string -refcount -assert -python-native -S../../../cio/cio-panda3d/built/include -S../../../cio/cio-panda3d/built/include/parser-inc -I./include -srcdir ./include -oc src/bsp_igate.cpp -od src/bsp.in -module bsp -library bsp -Dvolatile= -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall config_bsp.h bsploader.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_bsp
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "bsploader.h"
#include "config_bsp.h"
#include <dconfig.h>
#include <filename.h>
#include <genericAsyncTask.h>
#include <graphicsStateGuardian.h>
#include <lvector3.h>
#include <nodePath.h>
#include <pnmImage.h>
#include <texture.h>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class BSPLoader
 */
typedef BSPLoader BSPLoader_localtype;
Define_Module_Class(bsp, BSPLoader, BSPLoader_localtype, BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPLoader = &Dtool_BSPLoader;
static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != NULL, NULL);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// GraphicsStateGuardian
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsStateGuardian;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardian;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardian = &Dtool_GraphicsStateGuardian;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class BSPLoader
 */
/**
 * Python function wrapper for:
 * bool BSPLoader::read(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_read_3(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.read")) {
    return NULL;
  }
  // 1-bool BSPLoader::read(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.read", "Filename");
  }
  bool return_value = (*local_this).read(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const BSPLoader self, const Filename file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_read_3_comment =
  "C++ Interface:\n"
  "read(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_read_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
 */
static PyObject *Dtool_BSPLoader_set_gamma_4(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gamma")) {
    return NULL;
  }
  // 1-void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
  float param1;
  int param2 = 1;
  static const char *keyword_list[] = {"gamma", "overbright", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_gamma", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_gamma((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gamma(const BSPLoader self, float gamma, int overbright)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gamma_4_comment =
  "C++ Interface:\n"
  "set_gamma(const BSPLoader self, float gamma, int overbright)\n";
#else
static const char *Dtool_BSPLoader_set_gamma_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gsg(GraphicsStateGuardian *gsg)
 */
static PyObject *Dtool_BSPLoader_set_gsg_5(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gsg")) {
    return NULL;
  }
  // 1-void BSPLoader::set_gsg(GraphicsStateGuardian *gsg)
  GraphicsStateGuardian *arg_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardian, 1, "BSPLoader.set_gsg", false, true);
  if (arg_this != NULL) {
    (*local_this).set_gsg(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gsg(const BSPLoader self, GraphicsStateGuardian gsg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gsg_5_comment =
  "C++ Interface:\n"
  "set_gsg(const BSPLoader self, GraphicsStateGuardian gsg)\n";
#else
static const char *Dtool_BSPLoader_set_gsg_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_camera(NodePath const &camera)
 */
static PyObject *Dtool_BSPLoader_set_camera_6(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_camera")) {
    return NULL;
  }
  // 1-void BSPLoader::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_camera", true, true);
  if (arg_this != NULL) {
    (*local_this).set_camera(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera(const BSPLoader self, const NodePath camera)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_camera_6_comment =
  "C++ Interface:\n"
  "set_camera(const BSPLoader self, const NodePath camera)\n";
#else
static const char *Dtool_BSPLoader_set_camera_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_render(NodePath const &render)
 */
static PyObject *Dtool_BSPLoader_set_render_7(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_render")) {
    return NULL;
  }
  // 1-void BSPLoader::set_render(NodePath const &render)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_render", true, true);
  if (arg_this != NULL) {
    (*local_this).set_render(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render(const BSPLoader self, const NodePath render)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_render_7_comment =
  "C++ Interface:\n"
  "set_render(const BSPLoader self, const NodePath render)\n";
#else
static const char *Dtool_BSPLoader_set_render_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_visibility(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_visibility_8(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_visibility")) {
    return NULL;
  }
  // 1-void BSPLoader::set_want_visibility(bool flag)
  (*local_this).set_want_visibility((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_visibility(const BSPLoader self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_visibility_8_comment =
  "C++ Interface:\n"
  "set_want_visibility(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_visibility_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_physics_type(int type)
 */
static PyObject *Dtool_BSPLoader_set_physics_type_9(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_physics_type")) {
    return NULL;
  }
  // 1-void BSPLoader::set_physics_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_physics_type((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_type(const BSPLoader self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_physics_type_9_comment =
  "C++ Interface:\n"
  "set_physics_type(const BSPLoader self, int type)\n";
#else
static const char *Dtool_BSPLoader_set_physics_type_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_num_entities(void) const
 */
static PyObject *Dtool_BSPLoader_get_num_entities_10(PyObject *self, PyObject *) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-int BSPLoader::get_num_entities(void) const
  int return_value = (*(const BSPLoader*)local_this).get_num_entities();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_num_entities_10_comment =
  "C++ Interface:\n"
  "get_num_entities(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_num_entities_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string BSPLoader::get_entity_value(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_11(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-std::string BSPLoader::get_entity_value(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value", (char **)keyword_list, &param1, &param2)) {
    std::string return_value = (*(const BSPLoader*)local_this).get_entity_value((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value(BSPLoader self, int entnum, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_11_comment =
  "C++ Interface:\n"
  "get_entity_value(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * float BSPLoader::get_entity_value_float(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_float_12(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-float BSPLoader::get_entity_value_float(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_float", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const BSPLoader*)local_this).get_entity_value_float((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_float(BSPLoader self, int entnum, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_float_12_comment =
  "C++ Interface:\n"
  "get_entity_value_float(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_float_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_entity_value_int(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_int_13(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-int BSPLoader::get_entity_value_int(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_int", (char **)keyword_list, &param1, &param2)) {
    int return_value = (*(const BSPLoader*)local_this).get_entity_value_int((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_int(BSPLoader self, int entnum, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_int_13_comment =
  "C++ Interface:\n"
  "get_entity_value_int(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_int_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_vector_14(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_vector", (char **)keyword_list, &param1, &param2)) {
    LVector3 *return_value = new LVector3((*(const BSPLoader*)local_this).get_entity_value_vector((int)param1, (char const *)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_vector(BSPLoader self, int entnum, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_vector_14_comment =
  "C++ Interface:\n"
  "get_entity_value_vector(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_vector_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_color_15(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
  int param1;
  char const *param2;
  PyObject *param3 = Py_True;
  static const char *keyword_list[] = {"entnum", "key", "scale", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz|O:get_entity_value_color", (char **)keyword_list, &param1, &param2, &param3)) {
    LColor *return_value = new LColor((*(const BSPLoader*)local_this).get_entity_value_color((int)param1, (char const *)param2, (PyObject_IsTrue(param3) != 0)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_color_15_comment =
  "C++ Interface:\n"
  "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_color_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_entity(int entnum) const
 */
static PyObject *Dtool_BSPLoader_get_entity_16(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-NodePath BSPLoader::get_entity(int entnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_entity((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity(BSPLoader self, int entnum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_16_comment =
  "C++ Interface:\n"
  "get_entity(BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_get_entity_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_model(int modelnum) const
 */
static PyObject *Dtool_BSPLoader_get_model_17(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-NodePath BSPLoader::get_model(int modelnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_model((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model(BSPLoader self, int modelnum)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_17_comment =
  "C++ Interface:\n"
  "get_model(BSPLoader self, int modelnum)\n";
#else
static const char *Dtool_BSPLoader_get_model_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cleanup(void)
 */
static PyObject *Dtool_BSPLoader_cleanup_18(PyObject *self, PyObject *) {
  BSPLoader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cleanup")) {
    return NULL;
  }
  // 1-void BSPLoader::cleanup(void)
  (*local_this).cleanup();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cleanup_18_comment =
  "C++ Interface:\n"
  "cleanup(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_cleanup_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_result(void) const
 */
static PyObject *Dtool_BSPLoader_get_result_19(PyObject *self, PyObject *) {
  BSPLoader *local_this = NULL;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return NULL;
  }
  // 1-NodePath BSPLoader::get_result(void) const
  NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_result());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_result_19_comment =
  "C++ Interface:\n"
  "get_result(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_result_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * BSPLoader::BSPLoader(void)
 * inline BSPLoader::BSPLoader(BSPLoader const &) = default
 */
static int Dtool_Init_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != NULL && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BSPLoader() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-BSPLoader::BSPLoader(void)
      BSPLoader *return_value = new BSPLoader();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPLoader, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPLoader::BSPLoader(BSPLoader const &) = default
      BSPLoader const *arg_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPLoader, 0, "BSPLoader.BSPLoader", true, true);
      if (arg_this != NULL) {
        BSPLoader *return_value = new BSPLoader(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPLoader, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPLoader() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPLoader()\n"
      "BSPLoader(const BSPLoader param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPLoader) {
    printf("BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  BSPLoader *local_this = (BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPLoader) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for BSPLoader (BSPLoader)
 */
static PyMethodDef Dtool_Methods_BSPLoader[] = {
  {"read", &Dtool_BSPLoader_read_3, METH_O, (const char *)Dtool_BSPLoader_read_3_comment},
  {"set_gamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_4_comment},
  {"setGamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_4_comment},
  {"set_gsg", &Dtool_BSPLoader_set_gsg_5, METH_O, (const char *)Dtool_BSPLoader_set_gsg_5_comment},
  {"setGsg", &Dtool_BSPLoader_set_gsg_5, METH_O, (const char *)Dtool_BSPLoader_set_gsg_5_comment},
  {"set_camera", &Dtool_BSPLoader_set_camera_6, METH_O, (const char *)Dtool_BSPLoader_set_camera_6_comment},
  {"setCamera", &Dtool_BSPLoader_set_camera_6, METH_O, (const char *)Dtool_BSPLoader_set_camera_6_comment},
  {"set_render", &Dtool_BSPLoader_set_render_7, METH_O, (const char *)Dtool_BSPLoader_set_render_7_comment},
  {"setRender", &Dtool_BSPLoader_set_render_7, METH_O, (const char *)Dtool_BSPLoader_set_render_7_comment},
  {"set_want_visibility", &Dtool_BSPLoader_set_want_visibility_8, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_8_comment},
  {"setWantVisibility", &Dtool_BSPLoader_set_want_visibility_8, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_8_comment},
  {"set_physics_type", &Dtool_BSPLoader_set_physics_type_9, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_9_comment},
  {"setPhysicsType", &Dtool_BSPLoader_set_physics_type_9, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_9_comment},
  {"get_num_entities", &Dtool_BSPLoader_get_num_entities_10, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_10_comment},
  {"getNumEntities", &Dtool_BSPLoader_get_num_entities_10, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_10_comment},
  {"get_entity_value", (PyCFunction) &Dtool_BSPLoader_get_entity_value_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_11_comment},
  {"getEntityValue", (PyCFunction) &Dtool_BSPLoader_get_entity_value_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_11_comment},
  {"get_entity_value_float", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_12_comment},
  {"getEntityValueFloat", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_12_comment},
  {"get_entity_value_int", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_13_comment},
  {"getEntityValueInt", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_13_comment},
  {"get_entity_value_vector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_14_comment},
  {"getEntityValueVector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_14_comment},
  {"get_entity_value_color", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_15_comment},
  {"getEntityValueColor", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_15_comment},
  {"get_entity", &Dtool_BSPLoader_get_entity_16, METH_O, (const char *)Dtool_BSPLoader_get_entity_16_comment},
  {"getEntity", &Dtool_BSPLoader_get_entity_16, METH_O, (const char *)Dtool_BSPLoader_get_entity_16_comment},
  {"get_model", &Dtool_BSPLoader_get_model_17, METH_O, (const char *)Dtool_BSPLoader_get_model_17_comment},
  {"getModel", &Dtool_BSPLoader_get_model_17, METH_O, (const char *)Dtool_BSPLoader_get_model_17_comment},
  {"cleanup", &Dtool_BSPLoader_cleanup_18, METH_NOARGS, (const char *)Dtool_BSPLoader_cleanup_18_comment},
  {"get_result", &Dtool_BSPLoader_get_result_19, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_19_comment},
  {"getResult", &Dtool_BSPLoader_get_result_19, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_19_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_BSPLoader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "bsp.BSPLoader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPLoader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_VERSION_HEX >= 0x03050000
    0, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_BSPLoader,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    0, // tp_getattro
    0, // tp_setattro
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_BSPLoader,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_BSPLoader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPLoader,
  Dtool_UpcastInterface_BSPLoader,
  Dtool_DowncastInterface_BSPLoader,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BSPLoader._PyType.tp_base = (PyTypeObject *)&Dtool_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPLoader::PhysicsType;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PT_panda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PTPanda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PT_bullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PTBullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PT_ode", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PTOde", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PT_physx", Dtool_WrapValue(BSPLoader::PT_physx));
    PyDict_SetItemString(dict, "PTPhysx", Dtool_WrapValue(BSPLoader::PT_physx));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPLoader);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_bsp_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BSPLoader", Dtool_BSPLoader);
#endif
}

void Dtool_bsp_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_GraphicsStateGuardian = LookupRuntimeTypedClass(GraphicsStateGuardian::get_class_type());
#endif
}

void Dtool_bsp_BuildInstants(PyObject *module) {
  (void) module;
  // BSPLoader
  Dtool_PyModuleClassInit_BSPLoader(module);
  PyModule_AddObject(module, "BSPLoader", (PyObject *)&Dtool_BSPLoader);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef bsp_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1525269468,  /* file_identifier */
  "bsp",  /* library_name */
  "t5GT",  /* library_hash_name */
  "bsp",  /* module_name */
  "bsp.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  66  /* next_index */
};

Configure(_in_configure_bsp);
ConfigureFn(_in_configure_bsp) {
  interrogate_request_module(&_in_module_def);
}

