/*
 * This file was generated by:
 * ..\..\..\cio\cio-panda3d\built_x64\bin\interrogate -fnames -string -refcount -assert -python-native -S../../../cio/cio-panda3d/built_x64/include -S../../../cio/cio-panda3d/built_x64/include/parser-inc -I./include -srcdir ./include -oc src/bsp_igate.cpp -od src/bsp.in -module bsp -library bsp -Dvolatile= -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall config_bsp.h bsploader.h entity.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_bsp
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <boundingBox.h>
#include "bsploader.h"
#include "config_bsp.h"
#include <dconfig.h>
#include "entity.h"
#include <filename.h>
#include <genericAsyncTask.h>
#include <geom.h>
#include <graphicsStateGuardian.h>
#include <lightReMutex.h>
#include <lvector3.h>
#include <nodePath.h>
#include <pnmImage.h>
#include <py_panda.h>
#include <renderAttrib.h>
#include <texture.h>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CBaseEntity
 */
typedef CBaseEntity CBaseEntity_localtype;
Define_Module_ClassRef(bsp, CBaseEntity, CBaseEntity_localtype, CBaseEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBaseEntity = &Dtool_CBaseEntity;
static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module);

/**
 * Forward declarations for top-level class CPointEntity
 */
typedef CPointEntity CPointEntity_localtype;
Define_Module_ClassRef(bsp, CPointEntity, CPointEntity_localtype, CPointEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CPointEntity = &Dtool_CPointEntity;
static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBoundsEntity
 */
typedef CBoundsEntity CBoundsEntity_localtype;
Define_Module_ClassRef(bsp, CBoundsEntity, CBoundsEntity_localtype, CBoundsEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBoundsEntity = &Dtool_CBoundsEntity;
static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBrushEntity
 */
typedef CBrushEntity CBrushEntity_localtype;
Define_Module_ClassRef(bsp, CBrushEntity, CBrushEntity_localtype, CBrushEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBrushEntity = &Dtool_CBrushEntity;
static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module);

/**
 * Forward declarations for top-level class BSPGeomNode
 */
typedef BSPGeomNode BSPGeomNode_localtype;
Define_Module_ClassRef(bsp, BSPGeomNode, BSPGeomNode_localtype, BSPGeomNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPGeomNode = &Dtool_BSPGeomNode;
static void Dtool_PyModuleClassInit_BSPGeomNode(PyObject *module);

/**
 * Forward declarations for top-level class BSPFaceAttrib
 */
typedef BSPFaceAttrib BSPFaceAttrib_localtype;
Define_Module_ClassRef(bsp, BSPFaceAttrib, BSPFaceAttrib_localtype, BSPFaceAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPFaceAttrib = &Dtool_BSPFaceAttrib;
static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module);
bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced);

/**
 * Forward declarations for top-level class BSPLoader
 */
typedef BSPLoader BSPLoader_localtype;
Define_Module_Class(bsp, BSPLoader, BSPLoader_localtype, BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPLoader = &Dtool_BSPLoader;
static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVector3f;
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LPoint3f;
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// RenderAttrib
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_RenderAttrib;
#else
extern struct Dtool_PyTypedObject Dtool_RenderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderAttrib = &Dtool_RenderAttrib;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomNode;
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// GraphicsStateGuardian
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsStateGuardian;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardian;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardian = &Dtool_GraphicsStateGuardian;
#endif
// BoundingBox
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BoundingBox;
#else
extern struct Dtool_PyTypedObject Dtool_BoundingBox;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingBox = &Dtool_BoundingBox;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CBaseEntity
 */
/**
 * Python function wrapper for:
 * int CBaseEntity::get_entnum(void) const
 */
static PyObject *Dtool_CBaseEntity_get_entnum_4(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-int CBaseEntity::get_entnum(void) const
  int return_value = (*(const CBaseEntity*)local_this).get_entnum();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_entnum_4_comment =
  "C++ Interface:\n"
  "get_entnum(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_entnum_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BSPLoader *CBaseEntity::get_loader(void) const
 */
static PyObject *Dtool_CBaseEntity_get_loader_5(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-BSPLoader *CBaseEntity::get_loader(void) const
  BSPLoader *return_value = (*(const CBaseEntity*)local_this).get_loader();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_loader_5_comment =
  "C++ Interface:\n"
  "get_loader(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_loader_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CBaseEntity::get_class_type(void)
 */
static PyObject *Dtool_CBaseEntity_get_class_type_6(PyObject *, PyObject *) {
  // 1-static TypeHandle CBaseEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBaseEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_class_type_6_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBaseEntity_get_class_type_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBaseEntity::CBaseEntity(void)
 * inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
 */
static int Dtool_Init_CBaseEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBaseEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBaseEntity::CBaseEntity(void)
      CBaseEntity *return_value = new CBaseEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
      CBaseEntity const *arg_this = (CBaseEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBaseEntity, 0, "CBaseEntity.CBaseEntity", true, true);
      if (arg_this != nullptr) {
        CBaseEntity *return_value = new CBaseEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBaseEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBaseEntity()\n"
      "CBaseEntity(const CBaseEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBaseEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBaseEntity) {
    printf("CBaseEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBaseEntity *local_this = (CBaseEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBaseEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBaseEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CPointEntity
 */
/**
 * Python function wrapper for:
 * LPoint3 CPointEntity::get_origin(void) const
 */
static PyObject *Dtool_CPointEntity_get_origin_10(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LPoint3 CPointEntity::get_origin(void) const
  LPoint3 *return_value = new LPoint3((*(const CPointEntity*)local_this).get_origin());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_origin_10_comment =
  "C++ Interface:\n"
  "get_origin(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_origin_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CPointEntity::get_angles(void) const
 */
static PyObject *Dtool_CPointEntity_get_angles_11(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LVector3 CPointEntity::get_angles(void) const
  LVector3 *return_value = new LVector3((*(const CPointEntity*)local_this).get_angles());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_angles_11_comment =
  "C++ Interface:\n"
  "get_angles(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_angles_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CPointEntity::get_class_type(void)
 */
static PyObject *Dtool_CPointEntity_get_class_type_12(PyObject *, PyObject *) {
  // 1-static TypeHandle CPointEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CPointEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_class_type_12_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CPointEntity_get_class_type_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPointEntity::CPointEntity(void)
 * inline CPointEntity::CPointEntity(CPointEntity const &) = default
 */
static int Dtool_Init_CPointEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CPointEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CPointEntity::CPointEntity(void)
      CPointEntity *return_value = new CPointEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CPointEntity::CPointEntity(CPointEntity const &) = default
      CPointEntity const *arg_this = (CPointEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CPointEntity, 0, "CPointEntity.CPointEntity", true, true);
      if (arg_this != nullptr) {
        CPointEntity *return_value = new CPointEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CPointEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CPointEntity()\n"
      "CPointEntity(const CPointEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CPointEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CPointEntity) {
    printf("CPointEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CPointEntity *local_this = (CPointEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CPointEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CPointEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CPointEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBoundsEntity
 */
/**
 * Python function wrapper for:
 * BoundingBox *CBoundsEntity::get_bounds(void) const
 */
static PyObject *Dtool_CBoundsEntity_get_bounds_16(PyObject *self, PyObject *) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-BoundingBox *CBoundsEntity::get_bounds(void) const
  BoundingBox *return_value = (*(const CBoundsEntity*)local_this).get_bounds();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingBox, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_bounds_16_comment =
  "C++ Interface:\n"
  "get_bounds(CBoundsEntity self)\n";
#else
static const char *Dtool_CBoundsEntity_get_bounds_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CBoundsEntity::is_inside(LPoint3 const &pos) const
 */
static PyObject *Dtool_CBoundsEntity_is_inside_17(PyObject *self, PyObject *arg) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-inline bool CBoundsEntity::is_inside(LPoint3 const &pos) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CBoundsEntity.is_inside", "LPoint3f");
  }
  bool return_value = (*(const CBoundsEntity*)local_this).is_inside(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_inside(CBoundsEntity self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_is_inside_17_comment =
  "C++ Interface:\n"
  "is_inside(CBoundsEntity self, const LPoint3f pos)\n";
#else
static const char *Dtool_CBoundsEntity_is_inside_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CBoundsEntity::get_class_type(void)
 */
static PyObject *Dtool_CBoundsEntity_get_class_type_18(PyObject *, PyObject *) {
  // 1-static TypeHandle CBoundsEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBoundsEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_class_type_18_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBoundsEntity_get_class_type_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBoundsEntity::CBoundsEntity(void)
 * inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
 */
static int Dtool_Init_CBoundsEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBoundsEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBoundsEntity::CBoundsEntity(void)
      CBoundsEntity *return_value = new CBoundsEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
      CBoundsEntity const *arg_this = (CBoundsEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBoundsEntity, 0, "CBoundsEntity.CBoundsEntity", true, true);
      if (arg_this != nullptr) {
        CBoundsEntity *return_value = new CBoundsEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBoundsEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBoundsEntity()\n"
      "CBoundsEntity(const CBoundsEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBoundsEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBoundsEntity) {
    printf("CBoundsEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBoundsEntity *local_this = (CBoundsEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBoundsEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBoundsEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBoundsEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBrushEntity
 */
/**
 * Python function wrapper for:
 * int CBrushEntity::get_modelnum(void) const
 */
static PyObject *Dtool_CBrushEntity_get_modelnum_22(PyObject *self, PyObject *) {
  CBrushEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBrushEntity)) {
    return nullptr;
  }
  // 1-int CBrushEntity::get_modelnum(void) const
  int return_value = (*(const CBrushEntity*)local_this).get_modelnum();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_modelnum_22_comment =
  "C++ Interface:\n"
  "get_modelnum(CBrushEntity self)\n";
#else
static const char *Dtool_CBrushEntity_get_modelnum_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath CBrushEntity::get_model_np(void) const
 */
static PyObject *Dtool_CBrushEntity_get_model_np_23(PyObject *self, PyObject *) {
  CBrushEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBrushEntity)) {
    return nullptr;
  }
  // 1-NodePath CBrushEntity::get_model_np(void) const
  NodePath *return_value = new NodePath((*(const CBrushEntity*)local_this).get_model_np());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_np_23_comment =
  "C++ Interface:\n"
  "get_model_np(CBrushEntity self)\n";
#else
static const char *Dtool_CBrushEntity_get_model_np_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_CBrushEntity_get_model_bounds_24(PyObject *self, PyObject *args, PyObject *kwds) {
  CBrushEntity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CBrushEntity, (void **)&local_this, "CBrushEntity.get_model_bounds")) {
    return nullptr;
  }
  // 1-void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_model_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    (*local_this).get_model_bounds(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_bounds_24_comment =
  "C++ Interface:\n"
  "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_CBrushEntity_get_model_bounds_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CBrushEntity::get_class_type(void)
 */
static PyObject *Dtool_CBrushEntity_get_class_type_25(PyObject *, PyObject *) {
  // 1-static TypeHandle CBrushEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBrushEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_class_type_25_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBrushEntity_get_class_type_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBrushEntity::CBrushEntity(void)
 * inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
 */
static int Dtool_Init_CBrushEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBrushEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBrushEntity::CBrushEntity(void)
      CBrushEntity *return_value = new CBrushEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
      CBrushEntity const *arg_this = (CBrushEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBrushEntity, 0, "CBrushEntity.CBrushEntity", true, true);
      if (arg_this != nullptr) {
        CBrushEntity *return_value = new CBrushEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBrushEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBrushEntity()\n"
      "CBrushEntity(const CBrushEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBrushEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBrushEntity) {
    printf("CBrushEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBrushEntity *local_this = (CBrushEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBrushEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBrushEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBrushEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPGeomNode
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPGeomNode::get_class_type(void)
 */
static PyObject *Dtool_BSPGeomNode_get_class_type_30(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPGeomNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPGeomNode::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPGeomNode_get_class_type_30_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPGeomNode_get_class_type_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPGeomNode::BSPGeomNode(BSPGeomNode const &) = default
 * explicit BSPGeomNode::BSPGeomNode(std::string const &name)
 */
static int Dtool_Init_BSPGeomNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPGeomNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPGeomNode::BSPGeomNode(BSPGeomNode const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPGeomNode const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPGeomNode);
      if (param0_this != nullptr) {
        BSPGeomNode *return_value = new BSPGeomNode(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPGeomNode, true, false);
      }
    }
  }

  {
    // -2 explicit BSPGeomNode::BSPGeomNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPGeomNode", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPGeomNode *return_value = new BSPGeomNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPGeomNode, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline BSPGeomNode::BSPGeomNode(BSPGeomNode const &) = default
  // No coercion possible: explicit BSPGeomNode::BSPGeomNode(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPGeomNode(const BSPGeomNode param0)\n"
      "BSPGeomNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPGeomNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPGeomNode) {
    printf("BSPGeomNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPGeomNode *local_this = (BSPGeomNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPGeomNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GeomNode) {
    return (GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(GeomNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPGeomNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPGeomNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GeomNode) {
    GeomNode* other_this = (GeomNode*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPGeomNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPGeomNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPFaceAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material)
 */
static PyObject *Dtool_BSPFaceAttrib_make_34(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str face_material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_34_comment =
  "C++ Interface:\n"
  "make(str face_material)\n";
#else
static const char *Dtool_BSPFaceAttrib_make_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
 */
static PyObject *Dtool_BSPFaceAttrib_make_default_35(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make_default();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_default_35_comment =
  "C++ Interface:\n"
  "make_default()\n";
#else
static const char *Dtool_BSPFaceAttrib_make_default_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPFaceAttrib::get_material(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_material_36(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline std::string BSPFaceAttrib::get_material(void) const
  std::string return_value = (*(const BSPFaceAttrib*)local_this).get_material();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_material_36_comment =
  "C++ Interface:\n"
  "get_material(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_material_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int BSPFaceAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_slot_37(PyObject *, PyObject *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = BSPFaceAttrib::get_class_slot();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_slot_37_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_slot_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPFaceAttrib::get_class_type(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_type_40(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPFaceAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPFaceAttrib::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_type_40_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_type_40_comment = nullptr;
#endif

static PyObject *Dtool_BSPFaceAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = BSPFaceAttrib::get_class_slot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BSPFaceAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPFaceAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make(std::string(param0_str, param0_len));
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = MOVE((BSPFaceAttrib const *) return_value.p());
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPFaceAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPFaceAttrib) {
    printf("BSPFaceAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPFaceAttrib *local_this = (BSPFaceAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPFaceAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPFaceAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPFaceAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPLoader
 */
/**
 * Python function wrapper for:
 * bool BSPLoader::read(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_read_44(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.read")) {
    return nullptr;
  }
  // 1-bool BSPLoader::read(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.read", "Filename");
  }
  bool return_value = (*local_this).read(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const BSPLoader self, const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_read_44_comment =
  "C++ Interface:\n"
  "read(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_read_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::do_optimizations(void)
 */
static PyObject *Dtool_BSPLoader_do_optimizations_45(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.do_optimizations")) {
    return nullptr;
  }
  // 1-void BSPLoader::do_optimizations(void)
  (*local_this).do_optimizations();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_do_optimizations_45_comment =
  "C++ Interface:\n"
  "do_optimizations(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_do_optimizations_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
 */
static PyObject *Dtool_BSPLoader_set_gamma_46(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gamma")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
  float param1;
  int param2 = 1;
  static const char *keyword_list[] = {"gamma", "overbright", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_gamma", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_gamma((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gamma(const BSPLoader self, float gamma, int overbright)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gamma_46_comment =
  "C++ Interface:\n"
  "set_gamma(const BSPLoader self, float gamma, int overbright)\n";
#else
static const char *Dtool_BSPLoader_set_gamma_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gsg(GraphicsStateGuardian *gsg)
 */
static PyObject *Dtool_BSPLoader_set_gsg_47(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gsg")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_gsg(GraphicsStateGuardian *gsg)
  GraphicsStateGuardian *arg_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsStateGuardian, 1, "BSPLoader.set_gsg", false, true);
  if (arg_this != nullptr) {
    (*local_this).set_gsg(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gsg(const BSPLoader self, GraphicsStateGuardian gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gsg_47_comment =
  "C++ Interface:\n"
  "set_gsg(const BSPLoader self, GraphicsStateGuardian gsg)\n";
#else
static const char *Dtool_BSPLoader_set_gsg_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_camera(NodePath const &camera)
 */
static PyObject *Dtool_BSPLoader_set_camera_48(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_camera")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_camera", true, true);
  if (arg_this != nullptr) {
    (*local_this).set_camera(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera(const BSPLoader self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_camera_48_comment =
  "C++ Interface:\n"
  "set_camera(const BSPLoader self, const NodePath camera)\n";
#else
static const char *Dtool_BSPLoader_set_camera_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_render(NodePath const &render)
 */
static PyObject *Dtool_BSPLoader_set_render_49(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_render")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_render(NodePath const &render)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_render", true, true);
  if (arg_this != nullptr) {
    (*local_this).set_render(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render(const BSPLoader self, const NodePath render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_render_49_comment =
  "C++ Interface:\n"
  "set_render(const BSPLoader self, const NodePath render)\n";
#else
static const char *Dtool_BSPLoader_set_render_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_visibility(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_visibility_50(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_visibility")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_visibility(bool flag)
  (*local_this).set_want_visibility((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_visibility(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_visibility_50_comment =
  "C++ Interface:\n"
  "set_want_visibility(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_visibility_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_lightmaps(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_lightmaps_51(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_lightmaps")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_lightmaps(bool flag)
  (*local_this).set_want_lightmaps((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_lightmaps(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_lightmaps_51_comment =
  "C++ Interface:\n"
  "set_want_lightmaps(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_lightmaps_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_physics_type(int type)
 */
static PyObject *Dtool_BSPLoader_set_physics_type_52(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_physics_type")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_physics_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_physics_type((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_type(const BSPLoader self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_physics_type_52_comment =
  "C++ Interface:\n"
  "set_physics_type(const BSPLoader self, int type)\n";
#else
static const char *Dtool_BSPLoader_set_physics_type_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_visualize_leafs(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_visualize_leafs_53(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_visualize_leafs")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_visualize_leafs(bool flag)
  (*local_this).set_visualize_leafs((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visualize_leafs(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_visualize_leafs_53_comment =
  "C++ Interface:\n"
  "set_visualize_leafs(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_visualize_leafs_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_materials_file(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_set_materials_file_54(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_materials_file")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_materials_file(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_materials_file", "Filename");
  }
  (*local_this).set_materials_file(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_materials_file(const BSPLoader self, const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_materials_file_54_comment =
  "C++ Interface:\n"
  "set_materials_file(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_set_materials_file_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
 */
static PyObject *Dtool_BSPLoader_link_entity_to_class_55(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.link_entity_to_class")) {
    return nullptr;
  }
  // 1-void BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"entname", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:link_entity_to_class", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    if (PyType_Check(param2)) {
      (*local_this).link_entity_to_class(std::string(param1_str, param1_len), (PyTypeObject *)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_entity_to_class(const BSPLoader self, str entname, type type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_link_entity_to_class_55_comment =
  "C++ Interface:\n"
  "link_entity_to_class(const BSPLoader self, str entname, type type)\n";
#else
static const char *Dtool_BSPLoader_link_entity_to_class_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
 */
static PyObject *Dtool_BSPLoader_get_py_entity_by_target_name_56(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-PyObject *BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PyObject *return_value = (*(const BSPLoader*)local_this).get_py_entity_by_target_name(std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_py_entity_by_target_name(BSPLoader self, str targetname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_py_entity_by_target_name_56_comment =
  "C++ Interface:\n"
  "get_py_entity_by_target_name(BSPLoader self, str targetname)\n";
#else
static const char *Dtool_BSPLoader_get_py_entity_by_target_name_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_num_entities(void) const
 */
static PyObject *Dtool_BSPLoader_get_num_entities_57(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-int BSPLoader::get_num_entities(void) const
  int return_value = (*(const BSPLoader*)local_this).get_num_entities();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_num_entities_57_comment =
  "C++ Interface:\n"
  "get_num_entities(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_num_entities_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string BSPLoader::get_entity_value(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_58(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-std::string BSPLoader::get_entity_value(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value", (char **)keyword_list, &param1, &param2)) {
    std::string return_value = (*(const BSPLoader*)local_this).get_entity_value((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_58_comment =
  "C++ Interface:\n"
  "get_entity_value(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float BSPLoader::get_entity_value_float(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_float_59(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-float BSPLoader::get_entity_value_float(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_float", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const BSPLoader*)local_this).get_entity_value_float((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_float(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_float_59_comment =
  "C++ Interface:\n"
  "get_entity_value_float(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_float_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_entity_value_int(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_int_60(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-int BSPLoader::get_entity_value_int(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_int", (char **)keyword_list, &param1, &param2)) {
    int return_value = (*(const BSPLoader*)local_this).get_entity_value_int((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_int(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_int_60_comment =
  "C++ Interface:\n"
  "get_entity_value_int(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_int_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_vector_61(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_vector", (char **)keyword_list, &param1, &param2)) {
    LVector3 *return_value = new LVector3((*(const BSPLoader*)local_this).get_entity_value_vector((int)param1, (char const *)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_vector(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_vector_61_comment =
  "C++ Interface:\n"
  "get_entity_value_vector(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_vector_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_color_62(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
  int param1;
  char const *param2;
  PyObject *param3 = Py_True;
  static const char *keyword_list[] = {"entnum", "key", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz|O:get_entity_value_color", (char **)keyword_list, &param1, &param2, &param3)) {
    LColor *return_value = new LColor((*(const BSPLoader*)local_this).get_entity_value_color((int)param1, (char const *)param2, (PyObject_IsTrue(param3) != 0)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_color_62_comment =
  "C++ Interface:\n"
  "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_color_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_entity(int entnum) const
 */
static PyObject *Dtool_BSPLoader_get_entity_63(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_entity(int entnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_entity((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity(BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_63_comment =
  "C++ Interface:\n"
  "get_entity(BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_get_entity_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_model(int modelnum) const
 */
static PyObject *Dtool_BSPLoader_get_model_64(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_model(int modelnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_model((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model(BSPLoader self, int modelnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_64_comment =
  "C++ Interface:\n"
  "get_model(BSPLoader self, int modelnum)\n";
#else
static const char *Dtool_BSPLoader_get_model_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cull_node_path_against_leafs(NodePath &np, bool part_of_result = false)
 */
static PyObject *Dtool_BSPLoader_cull_node_path_against_leafs_65(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cull_node_path_against_leafs")) {
    return nullptr;
  }
  // 1-void BSPLoader::cull_node_path_against_leafs(NodePath &np, bool part_of_result = false)
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"np", "part_of_result", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:cull_node_path_against_leafs", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "BSPLoader.cull_node_path_against_leafs", false, true);
    if (param1_this != nullptr) {
      (*local_this).cull_node_path_against_leafs(*param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cull_node_path_against_leafs(const BSPLoader self, NodePath np, bool part_of_result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cull_node_path_against_leafs_65_comment =
  "C++ Interface:\n"
  "cull_node_path_against_leafs(const BSPLoader self, NodePath np, bool part_of_result)\n";
#else
static const char *Dtool_BSPLoader_cull_node_path_against_leafs_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::find_leaf(LPoint3 const &pos)
 * int BSPLoader::find_leaf(NodePath const &np)
 */
static PyObject *Dtool_BSPLoader_find_leaf_66(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_leaf")) {
    return nullptr;
  }
  {
    // -2 int BSPLoader::find_leaf(NodePath const &np)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = (*local_this).find_leaf(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int BSPLoader::find_leaf(NodePath const &np)
  {
    // -2 int BSPLoader::find_leaf(LPoint3 const &pos)
    LPoint3f arg_local;
    LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      int return_value = (*local_this).find_leaf(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_leaf(const BSPLoader self, const NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_leaf_66_comment =
  "C++ Interface:\n"
  "find_leaf(const BSPLoader self, const NodePath np)\n";
#else
static const char *Dtool_BSPLoader_find_leaf_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cleanup(void)
 */
static PyObject *Dtool_BSPLoader_cleanup_67(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cleanup")) {
    return nullptr;
  }
  // 1-void BSPLoader::cleanup(void)
  (*local_this).cleanup();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cleanup_67_comment =
  "C++ Interface:\n"
  "cleanup(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_cleanup_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_result(void) const
 */
static PyObject *Dtool_BSPLoader_get_result_68(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_result(void) const
  NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_result());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_result_68_comment =
  "C++ Interface:\n"
  "get_result(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_result_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static BSPLoader *BSPLoader::get_global_ptr(void)
 */
static PyObject *Dtool_BSPLoader_get_global_ptr_69(PyObject *, PyObject *) {
  // 1-static BSPLoader *BSPLoader::get_global_ptr(void)
  BSPLoader *return_value = BSPLoader::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_global_ptr_69_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_BSPLoader_get_global_ptr_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BSPLoader::BSPLoader(void)
 */
static int Dtool_Init_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BSPLoader() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPLoader() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-BSPLoader::BSPLoader(void)
  BSPLoader *return_value = new BSPLoader();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPLoader, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPLoader()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPLoader) {
    printf("BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPLoader *local_this = (BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPLoader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for CBaseEntity (CBaseEntity)
 */
static PyMethodDef Dtool_Methods_CBaseEntity[] = {
  {"get_entnum", &Dtool_CBaseEntity_get_entnum_4, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_entnum_4_comment},
  {"getEntnum", &Dtool_CBaseEntity_get_entnum_4, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_entnum_4_comment},
  {"get_loader", &Dtool_CBaseEntity_get_loader_5, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_5_comment},
  {"getLoader", &Dtool_CBaseEntity_get_loader_5, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_5_comment},
  {"get_class_type", &Dtool_CBaseEntity_get_class_type_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_6_comment},
  {"getClassType", &Dtool_CBaseEntity_get_class_type_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_6_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBaseEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBaseEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBaseEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBaseEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBaseEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBaseEntity,
    &Dtool_SequenceMethods_CBaseEntity,
    &Dtool_MappingMethods_CBaseEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBaseEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBaseEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBaseEntity,
    PyType_GenericAlloc,
    Dtool_new_CBaseEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBaseEntity,
  Dtool_UpcastInterface_CBaseEntity,
  Dtool_DowncastInterface_CBaseEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CBaseEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CBaseEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBaseEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBaseEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBaseEntity);
  }
}

/**
 * Python method tables for CPointEntity (CPointEntity)
 */
static PyMethodDef Dtool_Methods_CPointEntity[] = {
  {"get_origin", &Dtool_CPointEntity_get_origin_10, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_10_comment},
  {"getOrigin", &Dtool_CPointEntity_get_origin_10, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_10_comment},
  {"get_angles", &Dtool_CPointEntity_get_angles_11, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_11_comment},
  {"getAngles", &Dtool_CPointEntity_get_angles_11, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_11_comment},
  {"get_class_type", &Dtool_CPointEntity_get_class_type_12, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_12_comment},
  {"getClassType", &Dtool_CPointEntity_get_class_type_12, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_12_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CPointEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CPointEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CPointEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CPointEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CPointEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CPointEntity,
    &Dtool_SequenceMethods_CPointEntity,
    &Dtool_MappingMethods_CPointEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CPointEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CPointEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CPointEntity,
    PyType_GenericAlloc,
    Dtool_new_CPointEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CPointEntity,
  Dtool_UpcastInterface_CPointEntity,
  Dtool_DowncastInterface_CPointEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CPointEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CPointEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CPointEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CPointEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CPointEntity);
  }
}

/**
 * Python method tables for CBoundsEntity (CBoundsEntity)
 */
static PyMethodDef Dtool_Methods_CBoundsEntity[] = {
  {"get_bounds", &Dtool_CBoundsEntity_get_bounds_16, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_16_comment},
  {"getBounds", &Dtool_CBoundsEntity_get_bounds_16, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_16_comment},
  {"is_inside", &Dtool_CBoundsEntity_is_inside_17, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_17_comment},
  {"isInside", &Dtool_CBoundsEntity_is_inside_17, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_17_comment},
  {"get_class_type", &Dtool_CBoundsEntity_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_18_comment},
  {"getClassType", &Dtool_CBoundsEntity_get_class_type_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_18_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBoundsEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBoundsEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBoundsEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBoundsEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBoundsEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBoundsEntity,
    &Dtool_SequenceMethods_CBoundsEntity,
    &Dtool_MappingMethods_CBoundsEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBoundsEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A flavor of a brush entity (but doesn't inherit from CBrushEntity) which uses the brush only to describe\n"
    " * the bounds. Useful for triggers or water, because we don't actually care about the brush's geometry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBoundsEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBoundsEntity,
    PyType_GenericAlloc,
    Dtool_new_CBoundsEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBoundsEntity,
  Dtool_UpcastInterface_CBoundsEntity,
  Dtool_DowncastInterface_CBoundsEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBoundsEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CBoundsEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBoundsEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBoundsEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBoundsEntity);
  }
}

/**
 * Python method tables for CBrushEntity (CBrushEntity)
 */
static PyMethodDef Dtool_Methods_CBrushEntity[] = {
  {"get_modelnum", &Dtool_CBrushEntity_get_modelnum_22, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_modelnum_22_comment},
  {"getModelnum", &Dtool_CBrushEntity_get_modelnum_22, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_modelnum_22_comment},
  {"get_model_np", &Dtool_CBrushEntity_get_model_np_23, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_23_comment},
  {"getModelNp", &Dtool_CBrushEntity_get_model_np_23, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_23_comment},
  {"get_model_bounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_24_comment},
  {"getModelBounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_24_comment},
  {"get_class_type", &Dtool_CBrushEntity_get_class_type_25, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_25_comment},
  {"getClassType", &Dtool_CBrushEntity_get_class_type_25, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_25_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBrushEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBrushEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBrushEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBrushEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBrushEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBrushEntity,
    &Dtool_SequenceMethods_CBrushEntity,
    &Dtool_MappingMethods_CBrushEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBrushEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBrushEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBrushEntity,
    PyType_GenericAlloc,
    Dtool_new_CBrushEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBrushEntity,
  Dtool_UpcastInterface_CBrushEntity,
  Dtool_DowncastInterface_CBrushEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBrushEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CBrushEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBrushEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBrushEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBrushEntity);
  }
}

/**
 * Python method tables for BSPGeomNode (BSPGeomNode)
 */
static PyMethodDef Dtool_Methods_BSPGeomNode[] = {
  {"get_class_type", &Dtool_BSPGeomNode_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPGeomNode_get_class_type_30_comment},
  {"getClassType", &Dtool_BSPGeomNode_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPGeomNode_get_class_type_30_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPGeomNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPGeomNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPGeomNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPGeomNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPGeomNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPGeomNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPGeomNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPGeomNode,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPGeomNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPGeomNode,
    &Dtool_SequenceMethods_BSPGeomNode,
    &Dtool_MappingMethods_BSPGeomNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPGeomNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * All this class does is override GeomNode's add_for_draw to cull the Geoms\n"
    " * against the visible leaf AABBs.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPGeomNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPGeomNode,
    PyType_GenericAlloc,
    Dtool_new_BSPGeomNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPGeomNode,
  Dtool_UpcastInterface_BSPGeomNode,
  Dtool_DowncastInterface_BSPGeomNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPGeomNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_GeomNode != nullptr);
    assert(Dtool_Ptr_GeomNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_GeomNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPGeomNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_GeomNode);
    PyObject *dict = PyDict_New();
    Dtool_BSPGeomNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPGeomNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPGeomNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPGeomNode);
  }
}

/**
 * Python method tables for BSPFaceAttrib (BSPFaceAttrib)
 */
static PyMethodDef Dtool_Methods_BSPFaceAttrib[] = {
  {"make", &Dtool_BSPFaceAttrib_make_34, METH_O | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_34_comment},
  {"make_default", &Dtool_BSPFaceAttrib_make_default_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_35_comment},
  {"makeDefault", &Dtool_BSPFaceAttrib_make_default_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_35_comment},
  {"get_material", &Dtool_BSPFaceAttrib_get_material_36, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_36_comment},
  {"getMaterial", &Dtool_BSPFaceAttrib_get_material_36, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_36_comment},
  {"get_class_slot", &Dtool_BSPFaceAttrib_get_class_slot_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_37_comment},
  {"getClassSlot", &Dtool_BSPFaceAttrib_get_class_slot_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_37_comment},
  {"get_class_type", &Dtool_BSPFaceAttrib_get_class_type_40, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_40_comment},
  {"getClassType", &Dtool_BSPFaceAttrib_get_class_type_40, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_40_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPFaceAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPFaceAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPFaceAttrib",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPFaceAttrib,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPFaceAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPFaceAttrib,
    &Dtool_SequenceMethods_BSPFaceAttrib,
    &Dtool_MappingMethods_BSPFaceAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPFaceAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An attribute applied to each face Geom from a BSP file.\n"
    " * All it does right now is indicate the material of the face.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPFaceAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPFaceAttrib,
    PyType_GenericAlloc,
    Dtool_new_BSPFaceAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPFaceAttrib,
  Dtool_UpcastInterface_BSPFaceAttrib,
  Dtool_DowncastInterface_BSPFaceAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BSPFaceAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPFaceAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    PyObject *dict = PyDict_New();
    Dtool_BSPFaceAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BSPFaceAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BSPFaceAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPFaceAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPFaceAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPFaceAttrib);
  }
}

/**
 * Python method tables for BSPLoader (BSPLoader)
 */
static PyMethodDef Dtool_Methods_BSPLoader[] = {
  {"read", &Dtool_BSPLoader_read_44, METH_O, (const char *)Dtool_BSPLoader_read_44_comment},
  {"do_optimizations", &Dtool_BSPLoader_do_optimizations_45, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_45_comment},
  {"doOptimizations", &Dtool_BSPLoader_do_optimizations_45, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_45_comment},
  {"set_gamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_46_comment},
  {"setGamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_46_comment},
  {"set_gsg", &Dtool_BSPLoader_set_gsg_47, METH_O, (const char *)Dtool_BSPLoader_set_gsg_47_comment},
  {"setGsg", &Dtool_BSPLoader_set_gsg_47, METH_O, (const char *)Dtool_BSPLoader_set_gsg_47_comment},
  {"set_camera", &Dtool_BSPLoader_set_camera_48, METH_O, (const char *)Dtool_BSPLoader_set_camera_48_comment},
  {"setCamera", &Dtool_BSPLoader_set_camera_48, METH_O, (const char *)Dtool_BSPLoader_set_camera_48_comment},
  {"set_render", &Dtool_BSPLoader_set_render_49, METH_O, (const char *)Dtool_BSPLoader_set_render_49_comment},
  {"setRender", &Dtool_BSPLoader_set_render_49, METH_O, (const char *)Dtool_BSPLoader_set_render_49_comment},
  {"set_want_visibility", &Dtool_BSPLoader_set_want_visibility_50, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_50_comment},
  {"setWantVisibility", &Dtool_BSPLoader_set_want_visibility_50, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_50_comment},
  {"set_want_lightmaps", &Dtool_BSPLoader_set_want_lightmaps_51, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_51_comment},
  {"setWantLightmaps", &Dtool_BSPLoader_set_want_lightmaps_51, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_51_comment},
  {"set_physics_type", &Dtool_BSPLoader_set_physics_type_52, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_52_comment},
  {"setPhysicsType", &Dtool_BSPLoader_set_physics_type_52, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_52_comment},
  {"set_visualize_leafs", &Dtool_BSPLoader_set_visualize_leafs_53, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_53_comment},
  {"setVisualizeLeafs", &Dtool_BSPLoader_set_visualize_leafs_53, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_53_comment},
  {"set_materials_file", &Dtool_BSPLoader_set_materials_file_54, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_54_comment},
  {"setMaterialsFile", &Dtool_BSPLoader_set_materials_file_54, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_54_comment},
  {"link_entity_to_class", (PyCFunction) &Dtool_BSPLoader_link_entity_to_class_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_entity_to_class_55_comment},
  {"linkEntityToClass", (PyCFunction) &Dtool_BSPLoader_link_entity_to_class_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_entity_to_class_55_comment},
  {"get_py_entity_by_target_name", &Dtool_BSPLoader_get_py_entity_by_target_name_56, METH_O, (const char *)Dtool_BSPLoader_get_py_entity_by_target_name_56_comment},
  {"getPyEntityByTargetName", &Dtool_BSPLoader_get_py_entity_by_target_name_56, METH_O, (const char *)Dtool_BSPLoader_get_py_entity_by_target_name_56_comment},
  {"get_num_entities", &Dtool_BSPLoader_get_num_entities_57, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_57_comment},
  {"getNumEntities", &Dtool_BSPLoader_get_num_entities_57, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_57_comment},
  {"get_entity_value", (PyCFunction) &Dtool_BSPLoader_get_entity_value_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_58_comment},
  {"getEntityValue", (PyCFunction) &Dtool_BSPLoader_get_entity_value_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_58_comment},
  {"get_entity_value_float", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_59_comment},
  {"getEntityValueFloat", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_59_comment},
  {"get_entity_value_int", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_60_comment},
  {"getEntityValueInt", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_60_comment},
  {"get_entity_value_vector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_61_comment},
  {"getEntityValueVector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_61_comment},
  {"get_entity_value_color", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_62, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_62_comment},
  {"getEntityValueColor", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_62, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_62_comment},
  {"get_entity", &Dtool_BSPLoader_get_entity_63, METH_O, (const char *)Dtool_BSPLoader_get_entity_63_comment},
  {"getEntity", &Dtool_BSPLoader_get_entity_63, METH_O, (const char *)Dtool_BSPLoader_get_entity_63_comment},
  {"get_model", &Dtool_BSPLoader_get_model_64, METH_O, (const char *)Dtool_BSPLoader_get_model_64_comment},
  {"getModel", &Dtool_BSPLoader_get_model_64, METH_O, (const char *)Dtool_BSPLoader_get_model_64_comment},
  {"cull_node_path_against_leafs", (PyCFunction) &Dtool_BSPLoader_cull_node_path_against_leafs_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_cull_node_path_against_leafs_65_comment},
  {"cullNodePathAgainstLeafs", (PyCFunction) &Dtool_BSPLoader_cull_node_path_against_leafs_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_cull_node_path_against_leafs_65_comment},
  {"find_leaf", &Dtool_BSPLoader_find_leaf_66, METH_O, (const char *)Dtool_BSPLoader_find_leaf_66_comment},
  {"findLeaf", &Dtool_BSPLoader_find_leaf_66, METH_O, (const char *)Dtool_BSPLoader_find_leaf_66_comment},
  {"cleanup", &Dtool_BSPLoader_cleanup_67, METH_NOARGS, (const char *)Dtool_BSPLoader_cleanup_67_comment},
  {"get_result", &Dtool_BSPLoader_get_result_68, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_68_comment},
  {"getResult", &Dtool_BSPLoader_get_result_68, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_68_comment},
  {"get_global_ptr", &Dtool_BSPLoader_get_global_ptr_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_69_comment},
  {"getGlobalPtr", &Dtool_BSPLoader_get_global_ptr_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_69_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPLoader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPLoader,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPLoader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Loads and handles the operations of PBSP files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPLoader,
  Dtool_UpcastInterface_BSPLoader,
  Dtool_DowncastInterface_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BSPLoader._PyType.tp_base = (PyTypeObject *)&Dtool_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPLoader::PhysicsType;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PT_panda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PTPanda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PT_bullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PTBullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PT_ode", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PTOde", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PT_physx", Dtool_WrapValue(BSPLoader::PT_physx));
    PyDict_SetItemString(dict, "PTPhysx", Dtool_WrapValue(BSPLoader::PT_physx));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPLoader);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_bsp_RegisterTypes() {
  CBaseEntity::init_type();
  Dtool_CBaseEntity._type = CBaseEntity::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CBaseEntity);
  CPointEntity::init_type();
  Dtool_CPointEntity._type = CPointEntity::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CPointEntity);
  CBoundsEntity::init_type();
  Dtool_CBoundsEntity._type = CBoundsEntity::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CBoundsEntity);
  CBrushEntity::init_type();
  Dtool_CBrushEntity._type = CBrushEntity::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CBrushEntity);
  BSPGeomNode::init_type();
  Dtool_BSPGeomNode._type = BSPGeomNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BSPGeomNode);
  BSPFaceAttrib::init_type();
  Dtool_BSPFaceAttrib._type = BSPFaceAttrib::get_class_type();
  RegisterRuntimeTypedClass(Dtool_BSPFaceAttrib);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("BSPLoader", Dtool_BSPLoader);
#endif
}

void Dtool_bsp_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_LVector3f = LookupRuntimeTypedClass(LVector3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_LPoint3f = LookupRuntimeTypedClass(LPoint3f::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_RenderAttrib = LookupRuntimeTypedClass(RenderAttrib::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_GeomNode = LookupRuntimeTypedClass(GeomNode::get_class_type());
  Dtool_Ptr_GraphicsStateGuardian = LookupRuntimeTypedClass(GraphicsStateGuardian::get_class_type());
  Dtool_Ptr_BoundingBox = LookupRuntimeTypedClass(BoundingBox::get_class_type());
#endif
}

void Dtool_bsp_BuildInstants(PyObject *module) {
  (void) module;
  // CBaseEntity
  Dtool_PyModuleClassInit_CBaseEntity(module);
  PyModule_AddObject(module, "CBaseEntity", (PyObject *)&Dtool_CBaseEntity);
  // CPointEntity
  Dtool_PyModuleClassInit_CPointEntity(module);
  PyModule_AddObject(module, "CPointEntity", (PyObject *)&Dtool_CPointEntity);
  // CBoundsEntity
  Dtool_PyModuleClassInit_CBoundsEntity(module);
  PyModule_AddObject(module, "CBoundsEntity", (PyObject *)&Dtool_CBoundsEntity);
  // CBrushEntity
  Dtool_PyModuleClassInit_CBrushEntity(module);
  PyModule_AddObject(module, "CBrushEntity", (PyObject *)&Dtool_CBrushEntity);
  // BSPGeomNode
  Dtool_PyModuleClassInit_BSPGeomNode(module);
  PyModule_AddObject(module, "BSPGeomNode", (PyObject *)&Dtool_BSPGeomNode);
  // BSPFaceAttrib
  Dtool_PyModuleClassInit_BSPFaceAttrib(module);
  PyModule_AddObject(module, "BSPFaceAttrib", (PyObject *)&Dtool_BSPFaceAttrib);
  // BSPLoader
  Dtool_PyModuleClassInit_BSPLoader(module);
  PyModule_AddObject(module, "BSPLoader", (PyObject *)&Dtool_BSPLoader);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

struct LibraryDef bsp_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1531333379,  /* file_identifier */
  "bsp",  /* library_name */
  "t5GT",  /* library_hash_name */
  "bsp",  /* module_name */
  "bsp.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  187  /* next_index */
};

Configure(_in_configure_bsp);
ConfigureFn(_in_configure_bsp) {
  interrogate_request_module(&_in_module_def);
}

