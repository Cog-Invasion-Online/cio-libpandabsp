/*
 * This file was generated by:
 * ..\..\..\cio\cio-panda3d\built_x64\bin\interrogate -fnames -string -refcount -assert -python-native -S../../../cio/cio-panda3d/built_x64/include -S../../../cio/cio-panda3d/built_x64/include/parser-inc -I./include -srcdir ./include -oc src/bsp_igate.cpp -od src/bsp.in -module bsp -library bsp -Dvolatile= -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall config_bsp.h bsploader.h entity.h bsp_render.h shader_generator.h shader_spec.h bsp_material.h TexturePacker.h shader_vertexlitgeneric.h shader_lightmappedgeneric.h shader_unlitgeneric.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_bsp
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "TexturePacker.h"
#include "ambient_probes.h"
#include <boundingBox.h>
#include "bsp_material.h"
#include "bsp_render.h"
#include "bsploader.h"
#include "config_bsp.h"
#include "cubemaps.h"
#include <cullTraverser.h>
#include <cullableObject.h>
#include <dconfig.h>
#include "entity.h"
#include <filename.h>
#include <genericAsyncTask.h>
#include <geom.h>
#include <graphicsStateGuardian.h>
#include <graphicsWindow.h>
#include <lightReMutex.h>
#include "lightmap_palettes.h"
#include <lvector3.h>
#include <modelNode.h>
#include <nodePath.h>
#include <pandaNode.h>
#include <pnmImage.h>
#include <py_panda.h>
#include <renderAttrib.h>
#include <shaderGenerator.h>
#include "shader_features.h"
#include "shader_generator.h"
#include "shader_lightmappedgeneric.h"
#include "shader_spec.h"
#include "shader_unlitgeneric.h"
#include "shader_vertexlitgeneric.h"
#include <texture.h>
#include "vifparser.h"
#include <weakNodePath.h>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TextureStages
 */
typedef TextureStages TextureStages_localtype;
Define_Module_Class(bsp, TextureStages, TextureStages_localtype, TextureStages);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStages = &Dtool_TextureStages;
static void Dtool_PyModuleClassInit_TextureStages(PyObject *module);

/**
 * Forward declarations for top-level class BSPMaterial
 */
typedef BSPMaterial BSPMaterial_localtype;
Define_Module_ClassRef(bsp, BSPMaterial, BSPMaterial_localtype, BSPMaterial);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPMaterial = &Dtool_BSPMaterial;
static void Dtool_PyModuleClassInit_BSPMaterial(PyObject *module);

/**
 * Forward declarations for top-level class BSPMaterialAttrib
 */
typedef BSPMaterialAttrib BSPMaterialAttrib_localtype;
Define_Module_ClassRef(bsp, BSPMaterialAttrib, BSPMaterialAttrib_localtype, BSPMaterialAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPMaterialAttrib = &Dtool_BSPMaterialAttrib;
static void Dtool_PyModuleClassInit_BSPMaterialAttrib(PyObject *module);
bool Dtool_ConstCoerce_BSPMaterialAttrib(PyObject *args, CPT(BSPMaterialAttrib) &coerced);

/**
 * Forward declarations for top-level class CBaseEntity
 */
typedef CBaseEntity CBaseEntity_localtype;
Define_Module_ClassRef(bsp, CBaseEntity, CBaseEntity_localtype, CBaseEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBaseEntity = &Dtool_CBaseEntity;
static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module);

/**
 * Forward declarations for top-level class CPointEntity
 */
typedef CPointEntity CPointEntity_localtype;
Define_Module_ClassRef(bsp, CPointEntity, CPointEntity_localtype, CPointEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CPointEntity = &Dtool_CPointEntity;
static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBoundsEntity
 */
typedef CBoundsEntity CBoundsEntity_localtype;
Define_Module_ClassRef(bsp, CBoundsEntity, CBoundsEntity_localtype, CBoundsEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBoundsEntity = &Dtool_CBoundsEntity;
static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module);

/**
 * Forward declarations for top-level class CBrushEntity
 */
typedef CBrushEntity CBrushEntity_localtype;
Define_Module_ClassRef(bsp, CBrushEntity, CBrushEntity_localtype, CBrushEntity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CBrushEntity = &Dtool_CBrushEntity;
static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module);

/**
 * Forward declarations for top-level class PackResult
 */
typedef PackResult PackResult_localtype;
Define_Module_Class(bsp, PackResult, PackResult_localtype, PackResult);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PackResult = &Dtool_PackResult;
static void Dtool_PyModuleClassInit_PackResult(PyObject *module);

/**
 * Forward declarations for top-level class TextureLocation
 */
typedef TextureLocation TextureLocation_localtype;
Define_Module_Class(bsp, TextureLocation, TextureLocation_localtype, TextureLocation);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureLocation = &Dtool_TextureLocation;
static void Dtool_PyModuleClassInit_TextureLocation(PyObject *module);

/**
 * Forward declarations for top-level class TexturePacker
 */
typedef TexturePacker TexturePacker_localtype;
Define_Module_Class(bsp, TexturePacker, TexturePacker_localtype, TexturePacker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TexturePacker = &Dtool_TexturePacker;
static void Dtool_PyModuleClassInit_TexturePacker(PyObject *module);

/**
 * Forward declarations for top-level class BSPFaceAttrib
 */
typedef BSPFaceAttrib BSPFaceAttrib_localtype;
Define_Module_ClassRef(bsp, BSPFaceAttrib, BSPFaceAttrib_localtype, BSPFaceAttrib);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPFaceAttrib = &Dtool_BSPFaceAttrib;
static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module);
bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced);

/**
 * Forward declarations for top-level class BSPLoader
 */
typedef BSPLoader BSPLoader_localtype;
Define_Module_Class(bsp, BSPLoader, BSPLoader_localtype, BSPLoader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPLoader = &Dtool_BSPLoader;
static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module);

/**
 * Forward declarations for top-level class BSPCullTraverser
 */
typedef BSPCullTraverser BSPCullTraverser_localtype;
Define_Module_ClassRef(bsp, BSPCullTraverser, BSPCullTraverser_localtype, BSPCullTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPCullTraverser = &Dtool_BSPCullTraverser;
static void Dtool_PyModuleClassInit_BSPCullTraverser(PyObject *module);
bool Dtool_ConstCoerce_BSPCullTraverser(PyObject *args, CPT(BSPCullTraverser) &coerced);
bool Dtool_Coerce_BSPCullTraverser(PyObject *args, PT(BSPCullTraverser) &coerced);

/**
 * Forward declarations for top-level class BSPRender
 */
typedef BSPRender BSPRender_localtype;
Define_Module_ClassRef(bsp, BSPRender, BSPRender_localtype, BSPRender);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPRender = &Dtool_BSPRender;
static void Dtool_PyModuleClassInit_BSPRender(PyObject *module);
bool Dtool_ConstCoerce_BSPRender(PyObject *args, CPT(BSPRender) &coerced);
bool Dtool_Coerce_BSPRender(PyObject *args, PT(BSPRender) &coerced);

/**
 * Forward declarations for top-level class BSPRoot
 */
typedef BSPRoot BSPRoot_localtype;
Define_Module_ClassRef(bsp, BSPRoot, BSPRoot_localtype, BSPRoot);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPRoot = &Dtool_BSPRoot;
static void Dtool_PyModuleClassInit_BSPRoot(PyObject *module);
bool Dtool_ConstCoerce_BSPRoot(PyObject *args, CPT(BSPRoot) &coerced);
bool Dtool_Coerce_BSPRoot(PyObject *args, PT(BSPRoot) &coerced);

/**
 * Forward declarations for top-level class BSPProp
 */
typedef BSPProp BSPProp_localtype;
Define_Module_ClassRef(bsp, BSPProp, BSPProp_localtype, BSPProp);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPProp = &Dtool_BSPProp;
static void Dtool_PyModuleClassInit_BSPProp(PyObject *module);
bool Dtool_ConstCoerce_BSPProp(PyObject *args, CPT(BSPProp) &coerced);
bool Dtool_Coerce_BSPProp(PyObject *args, PT(BSPProp) &coerced);

/**
 * Forward declarations for top-level class BSPModel
 */
typedef BSPModel BSPModel_localtype;
Define_Module_ClassRef(bsp, BSPModel, BSPModel_localtype, BSPModel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BSPModel = &Dtool_BSPModel;
static void Dtool_PyModuleClassInit_BSPModel(PyObject *module);
bool Dtool_ConstCoerce_BSPModel(PyObject *args, CPT(BSPModel) &coerced);
bool Dtool_Coerce_BSPModel(PyObject *args, PT(BSPModel) &coerced);

/**
 * Forward declarations for top-level class ShaderPermutations
 */
typedef ShaderPermutations ShaderPermutations_localtype;
Define_Module_Class(bsp, ShaderPermutations, ShaderPermutations_localtype, ShaderPermutations);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderPermutations = &Dtool_ShaderPermutations;
static void Dtool_PyModuleClassInit_ShaderPermutations(PyObject *module);

/**
 * Forward declarations for top-level class ShaderSpec
 */
typedef ShaderSpec ShaderSpec_localtype;
Define_Module_ClassRef(bsp, ShaderSpec, ShaderSpec_localtype, ShaderSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderSpec = &Dtool_ShaderSpec;
static void Dtool_PyModuleClassInit_ShaderSpec(PyObject *module);
bool Dtool_ConstCoerce_ShaderSpec(PyObject *args, CPT(ShaderSpec) &coerced);
bool Dtool_Coerce_ShaderSpec(PyObject *args, PT(ShaderSpec) &coerced);

/**
 * Forward declarations for top-level class PSSMShaderGenerator
 */
typedef PSSMShaderGenerator PSSMShaderGenerator_localtype;
Define_Module_ClassRef(bsp, PSSMShaderGenerator, PSSMShaderGenerator_localtype, PSSMShaderGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PSSMShaderGenerator = &Dtool_PSSMShaderGenerator;
static void Dtool_PyModuleClassInit_PSSMShaderGenerator(PyObject *module);
bool Dtool_ConstCoerce_PSSMShaderGenerator(PyObject *args, CPT(PSSMShaderGenerator) &coerced);
bool Dtool_Coerce_PSSMShaderGenerator(PyObject *args, PT(PSSMShaderGenerator) &coerced);

/**
 * Forward declarations for top-level class VertexLitGenericSpec
 */
typedef VertexLitGenericSpec VertexLitGenericSpec_localtype;
Define_Module_ClassRef(bsp, VertexLitGenericSpec, VertexLitGenericSpec_localtype, VertexLitGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VertexLitGenericSpec = &Dtool_VertexLitGenericSpec;
static void Dtool_PyModuleClassInit_VertexLitGenericSpec(PyObject *module);

/**
 * Forward declarations for top-level class LightmappedGenericSpec
 */
typedef LightmappedGenericSpec LightmappedGenericSpec_localtype;
Define_Module_ClassRef(bsp, LightmappedGenericSpec, LightmappedGenericSpec_localtype, LightmappedGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LightmappedGenericSpec = &Dtool_LightmappedGenericSpec;
static void Dtool_PyModuleClassInit_LightmappedGenericSpec(PyObject *module);

/**
 * Forward declarations for top-level class UnlitGenericSpec
 */
typedef UnlitGenericSpec UnlitGenericSpec_localtype;
Define_Module_ClassRef(bsp, UnlitGenericSpec, UnlitGenericSpec_localtype, UnlitGenericSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnlitGenericSpec = &Dtool_UnlitGenericSpec;
static void Dtool_PyModuleClassInit_UnlitGenericSpec(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TextureStages", &Dtool_TextureStages},
  {"BSPMaterial", &Dtool_BSPMaterial},
  {"BSPMaterialAttrib", &Dtool_BSPMaterialAttrib},
  {"CBaseEntity", &Dtool_CBaseEntity},
  {"CPointEntity", &Dtool_CPointEntity},
  {"CBoundsEntity", &Dtool_CBoundsEntity},
  {"CBrushEntity", &Dtool_CBrushEntity},
  {"PackResult", &Dtool_PackResult},
  {"TextureLocation", &Dtool_TextureLocation},
  {"TexturePacker", &Dtool_TexturePacker},
  {"BSPFaceAttrib", &Dtool_BSPFaceAttrib},
  {"BSPLoader", &Dtool_BSPLoader},
  {"BSPCullTraverser", &Dtool_BSPCullTraverser},
  {"BSPRender", &Dtool_BSPRender},
  {"BSPRoot", &Dtool_BSPRoot},
  {"BSPProp", &Dtool_BSPProp},
  {"BSPModel", &Dtool_BSPModel},
  {"ShaderPermutations", &Dtool_ShaderPermutations},
  {"ShaderSpec", &Dtool_ShaderSpec},
  {"PSSMShaderGenerator", &Dtool_PSSMShaderGenerator},
  {"VertexLitGenericSpec", &Dtool_VertexLitGenericSpec},
  {"LightmappedGenericSpec", &Dtool_LightmappedGenericSpec},
  {"UnlitGenericSpec", &Dtool_UnlitGenericSpec},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[1].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[4].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[5].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[6].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[7].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[8].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[9].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[10].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[11].type)
  {"GeometricBoundingVolume", nullptr},
#define Dtool_Ptr_GeometricBoundingVolume (imports[12].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[13].type)
  {"ShaderInput", nullptr},
#define Dtool_Ptr_ShaderInput (imports[14].type)
  {"TextureStage", nullptr},
#define Dtool_Ptr_TextureStage (imports[15].type)
  {"RenderAttrib", nullptr},
#define Dtool_Ptr_RenderAttrib (imports[16].type)
  {"TransformState", nullptr},
#define Dtool_Ptr_TransformState (imports[17].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[18].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[19].type)
  {"CullTraverser", nullptr},
#define Dtool_Ptr_CullTraverser (imports[20].type)
  {"ShaderGenerator", nullptr},
#define Dtool_Ptr_ShaderGenerator (imports[21].type)
  {"GraphicsStateGuardian", nullptr},
#define Dtool_Ptr_GraphicsStateGuardian (imports[22].type)
  {"BoundingBox", nullptr},
#define Dtool_Ptr_BoundingBox (imports[23].type)
  {"GraphicsWindow", nullptr},
#define Dtool_Ptr_GraphicsWindow (imports[24].type)
  {"ModelNode", nullptr},
#define Dtool_Ptr_ModelNode (imports[25].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// GeometricBoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GeometricBoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeometricBoundingVolume = &Dtool_GeometricBoundingVolume;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// ShaderInput
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ShaderInput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderInput = &Dtool_ShaderInput;
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// RenderAttrib
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_RenderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_RenderAttrib = &Dtool_RenderAttrib;
#endif
// TransformState
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// ShaderGenerator
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderGenerator = &Dtool_ShaderGenerator;
extern bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced);
extern bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced);
#endif
// GraphicsStateGuardian
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardian;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardian = &Dtool_GraphicsStateGuardian;
#endif
// BoundingBox
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BoundingBox;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingBox = &Dtool_BoundingBox;
#endif
// GraphicsWindow
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsWindow;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindow = &Dtool_GraphicsWindow;
#endif
// ModelNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ModelNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelNode = &Dtool_ModelNode;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class TextureStages
 */
/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get(std::string const &name)
 * static TextureStage *TextureStages::get(std::string const &name, std::string const &uv_name)
 */
static PyObject *Dtool_TextureStages_get_2(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
        // 1-static TextureStage *TextureStages::get(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
        param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
          param0_str = nullptr;
        }
#endif
        if (param0_str != nullptr) {
          TextureStage *return_value = TextureStages::get(std::string(param0_str, param0_len));
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 2:
    {
      // 1-static TextureStage *TextureStages::get(std::string const &name, std::string const &uv_name)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"name", "uv_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        TextureStage *return_value = TextureStages::get(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(str name)\n"
      "get(str name, str uv_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_2_comment =
  "C++ Interface:\n"
  "get(str name)\n"
  "get(str name, str uv_name)\n";
#else
static const char *Dtool_TextureStages_get_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_basetexture(void)
 */
static PyObject *Dtool_TextureStages_get_basetexture_3(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_basetexture(void)
  TextureStage *return_value = TextureStages::get_basetexture();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_basetexture_3_comment =
  "C++ Interface:\n"
  "get_basetexture()\n";
#else
static const char *Dtool_TextureStages_get_basetexture_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_lightmap(void)
 */
static PyObject *Dtool_TextureStages_get_lightmap_4(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_lightmap(void)
  TextureStage *return_value = TextureStages::get_lightmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_lightmap_4_comment =
  "C++ Interface:\n"
  "get_lightmap()\n";
#else
static const char *Dtool_TextureStages_get_lightmap_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_bumped_lightmap(void)
 */
static PyObject *Dtool_TextureStages_get_bumped_lightmap_5(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_bumped_lightmap(void)
  TextureStage *return_value = TextureStages::get_bumped_lightmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_bumped_lightmap_5_comment =
  "C++ Interface:\n"
  "get_bumped_lightmap()\n";
#else
static const char *Dtool_TextureStages_get_bumped_lightmap_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_spheremap(void)
 */
static PyObject *Dtool_TextureStages_get_spheremap_6(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_spheremap(void)
  TextureStage *return_value = TextureStages::get_spheremap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_spheremap_6_comment =
  "C++ Interface:\n"
  "get_spheremap()\n";
#else
static const char *Dtool_TextureStages_get_spheremap_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_cubemap(void)
 */
static PyObject *Dtool_TextureStages_get_cubemap_7(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_cubemap(void)
  TextureStage *return_value = TextureStages::get_cubemap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_cubemap_7_comment =
  "C++ Interface:\n"
  "get_cubemap()\n";
#else
static const char *Dtool_TextureStages_get_cubemap_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_normalmap(void)
 */
static PyObject *Dtool_TextureStages_get_normalmap_8(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_normalmap(void)
  TextureStage *return_value = TextureStages::get_normalmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_normalmap_8_comment =
  "C++ Interface:\n"
  "get_normalmap()\n";
#else
static const char *Dtool_TextureStages_get_normalmap_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_heightmap(void)
 */
static PyObject *Dtool_TextureStages_get_heightmap_9(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_heightmap(void)
  TextureStage *return_value = TextureStages::get_heightmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_heightmap_9_comment =
  "C++ Interface:\n"
  "get_heightmap()\n";
#else
static const char *Dtool_TextureStages_get_heightmap_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_glossmap(void)
 */
static PyObject *Dtool_TextureStages_get_glossmap_10(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_glossmap(void)
  TextureStage *return_value = TextureStages::get_glossmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_glossmap_10_comment =
  "C++ Interface:\n"
  "get_glossmap()\n";
#else
static const char *Dtool_TextureStages_get_glossmap_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TextureStage *TextureStages::get_glowmap(void)
 */
static PyObject *Dtool_TextureStages_get_glowmap_11(PyObject *, PyObject *) {
  // 1-static TextureStage *TextureStages::get_glowmap(void)
  TextureStage *return_value = TextureStages::get_glowmap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TextureStages_get_glowmap_11_comment =
  "C++ Interface:\n"
  "get_glowmap()\n";
#else
static const char *Dtool_TextureStages_get_glowmap_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureStages::TextureStages(void) = default
 * inline TextureStages::TextureStages(TextureStages const &) = default
 */
static int Dtool_Init_TextureStages(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TextureStages() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextureStages::TextureStages(void) = default
      TextureStages *return_value = new TextureStages();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStages, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TextureStages::TextureStages(TextureStages const &) = default
      TextureStages const *arg_this = (TextureStages *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStages, 0, "TextureStages.TextureStages", true, true);
      if (arg_this != nullptr) {
        TextureStages *return_value = new TextureStages(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureStages, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextureStages() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureStages()\n"
      "TextureStages(const TextureStages param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureStages(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureStages) {
    printf("TextureStages ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureStages *local_this = (TextureStages *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureStages) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureStages(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureStages) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPMaterial
 */
/**
 * Python function wrapper for:
 * inline void BSPMaterial::operator =(BSPMaterial const &copy)
 */
static PyObject *Dtool_BSPMaterial_operator_17(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.assign")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::operator =(BSPMaterial const &copy)
  BSPMaterial const *arg_this = (BSPMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPMaterial, 1, "BSPMaterial.assign", true, true);
  if (arg_this != nullptr) {
    (*local_this).operator =(*arg_this);
    BSPMaterial *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const BSPMaterial self, const BSPMaterial copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_operator_17_comment =
  "C++ Interface:\n"
  "assign(const BSPMaterial self, const BSPMaterial copy)\n";
#else
static const char *Dtool_BSPMaterial_operator_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPMaterial::set_keyvalue(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_BSPMaterial_set_keyvalue_18(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.set_keyvalue")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::set_keyvalue(std::string const &key, std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_keyvalue", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    (*local_this).set_keyvalue(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keyvalue(const BSPMaterial self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_set_keyvalue_18_comment =
  "C++ Interface:\n"
  "set_keyvalue(const BSPMaterial self, str key, str value)\n";
#else
static const char *Dtool_BSPMaterial_set_keyvalue_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_keyvalue(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_get_keyvalue_19(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_keyvalue(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = (*(const BSPMaterial*)local_this).get_keyvalue(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_keyvalue(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_keyvalue_19_comment =
  "C++ Interface:\n"
  "get_keyvalue(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_get_keyvalue_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPMaterial::set_shader(std::string const &shader_name)
 */
static PyObject *Dtool_BSPMaterial_set_shader_20(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPMaterial, (void **)&local_this, "BSPMaterial.set_shader")) {
    return nullptr;
  }
  // 1-inline void BSPMaterial::set_shader(std::string const &shader_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    (*local_this).set_shader(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader(const BSPMaterial self, str shader_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_set_shader_20_comment =
  "C++ Interface:\n"
  "set_shader(const BSPMaterial self, str shader_name)\n";
#else
static const char *Dtool_BSPMaterial_set_shader_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_shader(void) const
 */
static PyObject *Dtool_BSPMaterial_get_shader_21(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_shader(void) const
  std::string return_value = (*(const BSPMaterial*)local_this).get_shader();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_shader_21_comment =
  "C++ Interface:\n"
  "get_shader(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_shader_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename BSPMaterial::get_file(void) const
 */
static PyObject *Dtool_BSPMaterial_get_file_22(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline Filename BSPMaterial::get_file(void) const
  Filename *return_value = new Filename((*(const BSPMaterial*)local_this).get_file());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_file_22_comment =
  "C++ Interface:\n"
  "get_file(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_file_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_keyvalue(std::string const &key) const
 */
static PyObject *Dtool_BSPMaterial_has_keyvalue_23(PyObject *self, PyObject *arg) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_keyvalue(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = (*(const BSPMaterial*)local_this).has_keyvalue(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_keyvalue(BSPMaterial self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_keyvalue_23_comment =
  "C++ Interface:\n"
  "has_keyvalue(BSPMaterial self, str key)\n";
#else
static const char *Dtool_BSPMaterial_has_keyvalue_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPMaterial::has_env_cubemap(void) const
 */
static PyObject *Dtool_BSPMaterial_has_env_cubemap_24(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline bool BSPMaterial::has_env_cubemap(void) const
  bool return_value = (*(const BSPMaterial*)local_this).has_env_cubemap();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_has_env_cubemap_24_comment =
  "C++ Interface:\n"
  "has_env_cubemap(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_has_env_cubemap_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_surface_prop(void) const
 */
static PyObject *Dtool_BSPMaterial_get_surface_prop_25(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_surface_prop(void) const
  std::string return_value = (*(const BSPMaterial*)local_this).get_surface_prop();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_surface_prop_25_comment =
  "C++ Interface:\n"
  "get_surface_prop(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_surface_prop_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPMaterial::get_contents(void) const
 */
static PyObject *Dtool_BSPMaterial_get_contents_26(PyObject *self, PyObject *) {
  BSPMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterial)) {
    return nullptr;
  }
  // 1-inline std::string BSPMaterial::get_contents(void) const
  std::string return_value = (*(const BSPMaterial*)local_this).get_contents();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_contents_26_comment =
  "C++ Interface:\n"
  "get_contents(BSPMaterial self)\n";
#else
static const char *Dtool_BSPMaterial_get_contents_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static BSPMaterial const *BSPMaterial::get_from_file(Filename const &file)
 */
static PyObject *Dtool_BSPMaterial_get_from_file_27(PyObject *, PyObject *arg) {
  // 1-static BSPMaterial const *BSPMaterial::get_from_file(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "BSPMaterial.get_from_file", "Filename");
  }
  BSPMaterial const *return_value = BSPMaterial::get_from_file(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_from_file(const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_from_file_27_comment =
  "C++ Interface:\n"
  "get_from_file(const Filename file)\n";
#else
static const char *Dtool_BSPMaterial_get_from_file_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPMaterial::get_class_type(void)
 */
static PyObject *Dtool_BSPMaterial_get_class_type_28(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPMaterial::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPMaterial::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterial_get_class_type_28_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPMaterial_get_class_type_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
 * inline explicit BSPMaterial::BSPMaterial(std::string const &name = "VertexLitGeneric")
 */
static int Dtool_Init_BSPMaterial(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit BSPMaterial::BSPMaterial(std::string const &name)
      BSPMaterial *return_value = new BSPMaterial();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          BSPMaterial const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPMaterial);
          if (param0_this != nullptr) {
            BSPMaterial *return_value = new BSPMaterial(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
          }
        }
      }

      {
        // -2 inline explicit BSPMaterial::BSPMaterial(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPMaterial", (char **)keyword_list, &param0_str, &param0_len)) {
          BSPMaterial *return_value = new BSPMaterial(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPMaterial, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline BSPMaterial::BSPMaterial(BSPMaterial const &copy)
      // No coercion possible: inline explicit BSPMaterial::BSPMaterial(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPMaterial() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPMaterial()\n"
      "BSPMaterial(const BSPMaterial copy)\n"
      "BSPMaterial(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPMaterial(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPMaterial) {
    printf("BSPMaterial ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPMaterial *local_this = (BSPMaterial *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPMaterial) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPMaterial(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPMaterial) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BSPMaterial*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPMaterialAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
 */
static PyObject *Dtool_BSPMaterialAttrib_make_32(PyObject *, PyObject *arg) {
  // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
  BSPMaterial const *arg_this = (BSPMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BSPMaterial, 0, "BSPMaterialAttrib.make", true, true);
  if (arg_this != nullptr) {
    ConstPointerTo< RenderAttrib > return_value = BSPMaterialAttrib::make(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(const BSPMaterial mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_make_32_comment =
  "C++ Interface:\n"
  "make(const BSPMaterial mat)\n";
#else
static const char *Dtool_BSPMaterialAttrib_make_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_default(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_make_default_33(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = BSPMaterialAttrib::make_default();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_make_default_33_comment =
  "C++ Interface:\n"
  "make_default()\n";
#else
static const char *Dtool_BSPMaterialAttrib_make_default_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPMaterial const *BSPMaterialAttrib::get_material(void) const
 */
static PyObject *Dtool_BSPMaterialAttrib_get_material_34(PyObject *self, PyObject *) {
  BSPMaterialAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPMaterialAttrib)) {
    return nullptr;
  }
  // 1-inline BSPMaterial const *BSPMaterialAttrib::get_material(void) const
  BSPMaterial const *return_value = (*(const BSPMaterialAttrib*)local_this).get_material();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BSPMaterial, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_material_34_comment =
  "C++ Interface:\n"
  "get_material(BSPMaterialAttrib self)\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_material_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int BSPMaterialAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_get_class_slot_35(PyObject *, PyObject *) {
  // 1-static int BSPMaterialAttrib::get_class_slot(void)
  int return_value = BSPMaterialAttrib::get_class_slot();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_class_slot_35_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_class_slot_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPMaterialAttrib::get_class_type(void)
 */
static PyObject *Dtool_BSPMaterialAttrib_get_class_type_38(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPMaterialAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPMaterialAttrib::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPMaterialAttrib_get_class_type_38_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPMaterialAttrib_get_class_type_38_comment = nullptr;
#endif

static PyObject *Dtool_BSPMaterialAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BSPMaterialAttrib::get_class_slot(void)
  int return_value = BSPMaterialAttrib::get_class_slot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BSPMaterialAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BSPMaterialAttrib(PyObject *args, CPT(BSPMaterialAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPMaterialAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static ConstPointerTo< RenderAttrib > BSPMaterialAttrib::make(BSPMaterial const *mat)
    BSPMaterial const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BSPMaterial);
    if (arg_this != nullptr) {
      ConstPointerTo< RenderAttrib > return_value = BSPMaterialAttrib::make(arg_this);
      if (_PyErr_OCCURRED()) {
        return false;
      } else {
        coerced = std::move((BSPMaterialAttrib const *) return_value.p());
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPMaterialAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPMaterialAttrib) {
    printf("BSPMaterialAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPMaterialAttrib *local_this = (BSPMaterialAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPMaterialAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPMaterialAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPMaterialAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPMaterialAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBaseEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBaseEntity::get_class_type(void)
 */
static PyObject *Dtool_CBaseEntity_get_class_type_41(PyObject *, PyObject *) {
  // 1-static TypeHandle CBaseEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBaseEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_class_type_41_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBaseEntity_get_class_type_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CBaseEntity::get_entnum(void) const
 */
static PyObject *Dtool_CBaseEntity_get_entnum_43(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-int CBaseEntity::get_entnum(void) const
  int return_value = (*(const CBaseEntity*)local_this).get_entnum();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_entnum_43_comment =
  "C++ Interface:\n"
  "get_entnum(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_entnum_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BSPLoader *CBaseEntity::get_loader(void) const
 */
static PyObject *Dtool_CBaseEntity_get_loader_44(PyObject *self, PyObject *) {
  CBaseEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBaseEntity)) {
    return nullptr;
  }
  // 1-BSPLoader *CBaseEntity::get_loader(void) const
  BSPLoader *return_value = (*(const CBaseEntity*)local_this).get_loader();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CBaseEntity_get_loader_44_comment =
  "C++ Interface:\n"
  "get_loader(CBaseEntity self)\n";
#else
static const char *Dtool_CBaseEntity_get_loader_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBaseEntity::CBaseEntity(void)
 * inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
 */
static int Dtool_Init_CBaseEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBaseEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBaseEntity::CBaseEntity(void)
      CBaseEntity *return_value = new CBaseEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBaseEntity::CBaseEntity(CBaseEntity const &) = default
      CBaseEntity const *arg_this = (CBaseEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBaseEntity, 0, "CBaseEntity.CBaseEntity", true, true);
      if (arg_this != nullptr) {
        CBaseEntity *return_value = new CBaseEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBaseEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBaseEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBaseEntity()\n"
      "CBaseEntity(const CBaseEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBaseEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBaseEntity) {
    printf("CBaseEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBaseEntity *local_this = (CBaseEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBaseEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBaseEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBaseEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBaseEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CPointEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CPointEntity::get_class_type(void)
 */
static PyObject *Dtool_CPointEntity_get_class_type_47(PyObject *, PyObject *) {
  // 1-static TypeHandle CPointEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CPointEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_class_type_47_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CPointEntity_get_class_type_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CPointEntity::get_origin(void) const
 */
static PyObject *Dtool_CPointEntity_get_origin_49(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LPoint3 CPointEntity::get_origin(void) const
  LPoint3 *return_value = new LPoint3((*(const CPointEntity*)local_this).get_origin());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_origin_49_comment =
  "C++ Interface:\n"
  "get_origin(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_origin_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CPointEntity::get_angles(void) const
 */
static PyObject *Dtool_CPointEntity_get_angles_50(PyObject *self, PyObject *) {
  CPointEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CPointEntity)) {
    return nullptr;
  }
  // 1-LVector3 CPointEntity::get_angles(void) const
  LVector3 *return_value = new LVector3((*(const CPointEntity*)local_this).get_angles());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CPointEntity_get_angles_50_comment =
  "C++ Interface:\n"
  "get_angles(CPointEntity self)\n";
#else
static const char *Dtool_CPointEntity_get_angles_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPointEntity::CPointEntity(void)
 * inline CPointEntity::CPointEntity(CPointEntity const &) = default
 */
static int Dtool_Init_CPointEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CPointEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CPointEntity::CPointEntity(void)
      CPointEntity *return_value = new CPointEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CPointEntity::CPointEntity(CPointEntity const &) = default
      CPointEntity const *arg_this = (CPointEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CPointEntity, 0, "CPointEntity.CPointEntity", true, true);
      if (arg_this != nullptr) {
        CPointEntity *return_value = new CPointEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CPointEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CPointEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CPointEntity()\n"
      "CPointEntity(const CPointEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CPointEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CPointEntity) {
    printf("CPointEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CPointEntity *local_this = (CPointEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CPointEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CPointEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CPointEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CPointEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CPointEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBoundsEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBoundsEntity::get_class_type(void)
 */
static PyObject *Dtool_CBoundsEntity_get_class_type_53(PyObject *, PyObject *) {
  // 1-static TypeHandle CBoundsEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBoundsEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_class_type_53_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBoundsEntity_get_class_type_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BoundingBox *CBoundsEntity::get_bounds(void) const
 */
static PyObject *Dtool_CBoundsEntity_get_bounds_55(PyObject *self, PyObject *) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-BoundingBox *CBoundsEntity::get_bounds(void) const
  BoundingBox *return_value = (*(const CBoundsEntity*)local_this).get_bounds();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingBox, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_get_bounds_55_comment =
  "C++ Interface:\n"
  "get_bounds(CBoundsEntity self)\n";
#else
static const char *Dtool_CBoundsEntity_get_bounds_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CBoundsEntity::is_inside(LPoint3 const &pos) const
 */
static PyObject *Dtool_CBoundsEntity_is_inside_56(PyObject *self, PyObject *arg) {
  CBoundsEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBoundsEntity)) {
    return nullptr;
  }
  // 1-inline bool CBoundsEntity::is_inside(LPoint3 const &pos) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CBoundsEntity.is_inside", "LPoint3f");
  }
  bool return_value = (*(const CBoundsEntity*)local_this).is_inside(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_inside(CBoundsEntity self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_is_inside_56_comment =
  "C++ Interface:\n"
  "is_inside(CBoundsEntity self, const LPoint3f pos)\n";
#else
static const char *Dtool_CBoundsEntity_is_inside_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CBoundsEntity::fillin_bounds(LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_CBoundsEntity_fillin_bounds_57(PyObject *self, PyObject *args, PyObject *kwds) {
  CBoundsEntity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CBoundsEntity, (void **)&local_this, "CBoundsEntity.fillin_bounds")) {
    return nullptr;
  }
  // 1-void CBoundsEntity::fillin_bounds(LPoint3 &mins, LPoint3 &maxs)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:fillin_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CBoundsEntity.fillin_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CBoundsEntity.fillin_bounds", "LPoint3f");
    }
    (*local_this).fillin_bounds(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fillin_bounds(const CBoundsEntity self, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBoundsEntity_fillin_bounds_57_comment =
  "C++ Interface:\n"
  "fillin_bounds(const CBoundsEntity self, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_CBoundsEntity_fillin_bounds_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBoundsEntity::CBoundsEntity(void)
 * inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
 */
static int Dtool_Init_CBoundsEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBoundsEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBoundsEntity::CBoundsEntity(void)
      CBoundsEntity *return_value = new CBoundsEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBoundsEntity::CBoundsEntity(CBoundsEntity const &) = default
      CBoundsEntity const *arg_this = (CBoundsEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBoundsEntity, 0, "CBoundsEntity.CBoundsEntity", true, true);
      if (arg_this != nullptr) {
        CBoundsEntity *return_value = new CBoundsEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBoundsEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBoundsEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBoundsEntity()\n"
      "CBoundsEntity(const CBoundsEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBoundsEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBoundsEntity) {
    printf("CBoundsEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBoundsEntity *local_this = (CBoundsEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBoundsEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBoundsEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBoundsEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBoundsEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBoundsEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CBrushEntity
 */
/**
 * Python function wrapper for:
 * static TypeHandle CBrushEntity::get_class_type(void)
 */
static PyObject *Dtool_CBrushEntity_get_class_type_60(PyObject *, PyObject *) {
  // 1-static TypeHandle CBrushEntity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CBrushEntity::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_class_type_60_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CBrushEntity_get_class_type_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CBrushEntity::get_modelnum(void) const
 */
static PyObject *Dtool_CBrushEntity_get_modelnum_62(PyObject *self, PyObject *) {
  CBrushEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBrushEntity)) {
    return nullptr;
  }
  // 1-int CBrushEntity::get_modelnum(void) const
  int return_value = (*(const CBrushEntity*)local_this).get_modelnum();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_modelnum_62_comment =
  "C++ Interface:\n"
  "get_modelnum(CBrushEntity self)\n";
#else
static const char *Dtool_CBrushEntity_get_modelnum_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath CBrushEntity::get_model_np(void) const
 */
static PyObject *Dtool_CBrushEntity_get_model_np_63(PyObject *self, PyObject *) {
  CBrushEntity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CBrushEntity)) {
    return nullptr;
  }
  // 1-NodePath CBrushEntity::get_model_np(void) const
  NodePath *return_value = new NodePath((*(const CBrushEntity*)local_this).get_model_np());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_np_63_comment =
  "C++ Interface:\n"
  "get_model_np(CBrushEntity self)\n";
#else
static const char *Dtool_CBrushEntity_get_model_np_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_CBrushEntity_get_model_bounds_64(PyObject *self, PyObject *args, PyObject *kwds) {
  CBrushEntity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CBrushEntity, (void **)&local_this, "CBrushEntity.get_model_bounds")) {
    return nullptr;
  }
  // 1-void CBrushEntity::get_model_bounds(LPoint3 &mins, LPoint3 &maxs)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_model_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CBrushEntity.get_model_bounds", "LPoint3f");
    }
    (*local_this).get_model_bounds(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CBrushEntity_get_model_bounds_64_comment =
  "C++ Interface:\n"
  "get_model_bounds(const CBrushEntity self, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_CBrushEntity_get_model_bounds_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CBrushEntity::CBrushEntity(void)
 * inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
 */
static int Dtool_Init_CBrushEntity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CBrushEntity() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CBrushEntity::CBrushEntity(void)
      CBrushEntity *return_value = new CBrushEntity();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CBrushEntity::CBrushEntity(CBrushEntity const &) = default
      CBrushEntity const *arg_this = (CBrushEntity *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CBrushEntity, 0, "CBrushEntity.CBrushEntity", true, true);
      if (arg_this != nullptr) {
        CBrushEntity *return_value = new CBrushEntity(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CBrushEntity, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CBrushEntity() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CBrushEntity()\n"
      "CBrushEntity(const CBrushEntity param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CBrushEntity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CBrushEntity) {
    printf("CBrushEntity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CBrushEntity *local_this = (CBrushEntity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CBrushEntity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CBaseEntity) {
    return (CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CBaseEntity *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CBrushEntity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CBrushEntity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CBaseEntity) {
    CBaseEntity* other_this = (CBaseEntity*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CBrushEntity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CBrushEntity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PackResult
 */
/**
 * Python function wrapper for:
 * inline int PackResult::get_width(void) const
 */
static PyObject *Dtool_PackResult_get_width_67(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_width(void) const
  int return_value = (*(const PackResult*)local_this).get_width();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_width_67_comment =
  "C++ Interface:\n"
  "get_width(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_width_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PackResult::get_height(void) const
 */
static PyObject *Dtool_PackResult_get_height_68(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_height(void) const
  int return_value = (*(const PackResult*)local_this).get_height();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_height_68_comment =
  "C++ Interface:\n"
  "get_height(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_height_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PackResult::get_unused_area(void) const
 */
static PyObject *Dtool_PackResult_get_unused_area_69(PyObject *self, PyObject *) {
  PackResult *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PackResult)) {
    return nullptr;
  }
  // 1-inline int PackResult::get_unused_area(void) const
  int return_value = (*(const PackResult*)local_this).get_unused_area();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PackResult_get_unused_area_69_comment =
  "C++ Interface:\n"
  "get_unused_area(PackResult self)\n";
#else
static const char *Dtool_PackResult_get_unused_area_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PackResult::PackResult(PackResult const &) = default
 */
static int Dtool_Init_PackResult(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PackResult() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PackResult::PackResult(PackResult const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PackResult const *param0_this = (PackResult *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PackResult, 0, "PackResult.PackResult", true, true);
    if (param0_this != nullptr) {
      PackResult *return_value = new PackResult(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PackResult, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PackResult(const PackResult param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PackResult(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PackResult) {
    printf("PackResult ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PackResult *local_this = (PackResult *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PackResult) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PackResult(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PackResult) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TextureLocation
 */
/**
 * Python function wrapper for:
 * inline int TextureLocation::get_x(void) const
 */
static PyObject *Dtool_TextureLocation_get_x_73(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_x(void) const
  int return_value = (*(const TextureLocation*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_x_73_comment =
  "C++ Interface:\n"
  "get_x(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_x_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_y(void) const
 */
static PyObject *Dtool_TextureLocation_get_y_74(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_y(void) const
  int return_value = (*(const TextureLocation*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_y_74_comment =
  "C++ Interface:\n"
  "get_y(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_y_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_width(void) const
 */
static PyObject *Dtool_TextureLocation_get_width_75(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_width(void) const
  int return_value = (*(const TextureLocation*)local_this).get_width();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_width_75_comment =
  "C++ Interface:\n"
  "get_width(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_width_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TextureLocation::get_height(void) const
 */
static PyObject *Dtool_TextureLocation_get_height_76(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline int TextureLocation::get_height(void) const
  int return_value = (*(const TextureLocation*)local_this).get_height();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_height_76_comment =
  "C++ Interface:\n"
  "get_height(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_height_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TextureLocation::get_rotated(void) const
 */
static PyObject *Dtool_TextureLocation_get_rotated_77(PyObject *self, PyObject *) {
  TextureLocation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TextureLocation)) {
    return nullptr;
  }
  // 1-inline bool TextureLocation::get_rotated(void) const
  bool return_value = (*(const TextureLocation*)local_this).get_rotated();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextureLocation_get_rotated_77_comment =
  "C++ Interface:\n"
  "get_rotated(TextureLocation self)\n";
#else
static const char *Dtool_TextureLocation_get_rotated_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TextureLocation::TextureLocation(TextureLocation const &) = default
 */
static int Dtool_Init_TextureLocation(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TextureLocation() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TextureLocation::TextureLocation(TextureLocation const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TextureLocation const *param0_this = (TextureLocation *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TextureLocation, 0, "TextureLocation.TextureLocation", true, true);
    if (param0_this != nullptr) {
      TextureLocation *return_value = new TextureLocation(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextureLocation, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextureLocation(const TextureLocation param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextureLocation(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TextureLocation) {
    printf("TextureLocation ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TextureLocation *local_this = (TextureLocation *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TextureLocation) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TextureLocation(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TextureLocation) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TexturePacker
 */
/**
 * Python function wrapper for:
 * virtual int TexturePacker::getTextureCount(void) = 0
 */
static PyObject *Dtool_TexturePacker_getTextureCount_81(PyObject *self, PyObject *) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.getTextureCount")) {
    return nullptr;
  }
  // 1-virtual int TexturePacker::getTextureCount(void) = 0
  int return_value = (*local_this).getTextureCount();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_getTextureCount_81_comment =
  "C++ Interface:\n"
  "getTextureCount(const TexturePacker self)\n";
#else
static const char *Dtool_TexturePacker_getTextureCount_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::setTextureCount(int tcount) = 0
 */
static PyObject *Dtool_TexturePacker_setTextureCount_82(PyObject *self, PyObject *arg) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.setTextureCount")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::setTextureCount(int tcount) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).setTextureCount((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setTextureCount(const TexturePacker self, int tcount)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_setTextureCount_82_comment =
  "C++ Interface:\n"
  "setTextureCount(const TexturePacker self, int tcount)\n"
  "\n"
  "// number of textures to consider..";
#else
static const char *Dtool_TexturePacker_setTextureCount_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::addTexture(int wid, int hit) = 0
 */
static PyObject *Dtool_TexturePacker_addTexture_83(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.addTexture")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::addTexture(int wid, int hit) = 0
  int param1;
  int param2;
  static const char *keyword_list[] = {"wid", "hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:addTexture", (char **)keyword_list, &param1, &param2)) {
    (*local_this).addTexture((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "addTexture(const TexturePacker self, int wid, int hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_addTexture_83_comment =
  "C++ Interface:\n"
  "addTexture(const TexturePacker self, int wid, int hit)\n"
  "\n"
  "// add textures 0 - n";
#else
static const char *Dtool_TexturePacker_addTexture_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TexturePacker::wouldTextureFit(int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit) = 0
 */
static PyObject *Dtool_TexturePacker_wouldTextureFit_84(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.wouldTextureFit")) {
    return nullptr;
  }
  // 1-virtual bool TexturePacker::wouldTextureFit(int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit) = 0
  int param1;
  int param2;
  PyObject *param3;
  PyObject *param4;
  int param5;
  int param6;
  static const char *keyword_list[] = {"wid", "hit", "forcePowerOfTwo", "onePixelBorder", "max_wid", "max_hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOOii:wouldTextureFit", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    bool return_value = (*local_this).wouldTextureFit((int)param1, (int)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), (int)param5, (int)param6);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wouldTextureFit(const TexturePacker self, int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_wouldTextureFit_84_comment =
  "C++ Interface:\n"
  "wouldTextureFit(const TexturePacker self, int wid, int hit, bool forcePowerOfTwo, bool onePixelBorder, int max_wid, int max_hit)\n";
#else
static const char *Dtool_TexturePacker_wouldTextureFit_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void TexturePacker::addNewTexture(int wid, int hit) = 0
 */
static PyObject *Dtool_TexturePacker_addNewTexture_85(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.addNewTexture")) {
    return nullptr;
  }
  // 1-virtual void TexturePacker::addNewTexture(int wid, int hit) = 0
  int param1;
  int param2;
  static const char *keyword_list[] = {"wid", "hit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:addNewTexture", (char **)keyword_list, &param1, &param2)) {
    (*local_this).addNewTexture((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "addNewTexture(const TexturePacker self, int wid, int hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_addNewTexture_85_comment =
  "C++ Interface:\n"
  "addNewTexture(const TexturePacker self, int wid, int hit)\n";
#else
static const char *Dtool_TexturePacker_addNewTexture_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PackResult TexturePacker::packTextures(bool forcePowerOfTwo, bool onePixelBorder) = 0
 */
static PyObject *Dtool_TexturePacker_packTextures_86(PyObject *self, PyObject *args, PyObject *kwds) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.packTextures")) {
    return nullptr;
  }
  // 1-virtual PackResult TexturePacker::packTextures(bool forcePowerOfTwo, bool onePixelBorder) = 0
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"forcePowerOfTwo", "onePixelBorder", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:packTextures", (char **)keyword_list, &param1, &param2)) {
    PackResult *return_value = new PackResult((*local_this).packTextures((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PackResult, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "packTextures(const TexturePacker self, bool forcePowerOfTwo, bool onePixelBorder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_packTextures_86_comment =
  "C++ Interface:\n"
  "packTextures(const TexturePacker self, bool forcePowerOfTwo, bool onePixelBorder)\n"
  "\n"
  "// pack the textures, the return code is the amount of wasted/unused area.";
#else
static const char *Dtool_TexturePacker_packTextures_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TextureLocation TexturePacker::getTextureLocation(int index) = 0
 */
static PyObject *Dtool_TexturePacker_getTextureLocation_87(PyObject *self, PyObject *arg) {
  TexturePacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TexturePacker, (void **)&local_this, "TexturePacker.getTextureLocation")) {
    return nullptr;
  }
  // 1-virtual TextureLocation TexturePacker::getTextureLocation(int index) = 0
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextureLocation *return_value = new TextureLocation((*local_this).getTextureLocation((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TextureLocation, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "getTextureLocation(const TexturePacker self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_getTextureLocation_87_comment =
  "C++ Interface:\n"
  "getTextureLocation(const TexturePacker self, int index)\n"
  "\n"
  "// returns true if the texture has been rotated 90 degrees";
#else
static const char *Dtool_TexturePacker_getTextureLocation_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TexturePacker *TexturePacker::createTexturePacker(void)
 */
static PyObject *Dtool_TexturePacker_createTexturePacker_88(PyObject *, PyObject *) {
  // 1-static TexturePacker *TexturePacker::createTexturePacker(void)
  TexturePacker *return_value = TexturePacker::createTexturePacker();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TexturePacker, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_createTexturePacker_88_comment =
  "C++ Interface:\n"
  "createTexturePacker()\n";
#else
static const char *Dtool_TexturePacker_createTexturePacker_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void TexturePacker::releaseTexturePacker(TexturePacker *tp)
 */
static PyObject *Dtool_TexturePacker_releaseTexturePacker_89(PyObject *, PyObject *arg) {
  // 1-static void TexturePacker::releaseTexturePacker(TexturePacker *tp)
  TexturePacker *arg_this = (TexturePacker *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TexturePacker, 0, "TexturePacker.releaseTexturePacker", false, true);
  if (arg_this != nullptr) {
    TexturePacker::releaseTexturePacker(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "releaseTexturePacker(TexturePacker tp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TexturePacker_releaseTexturePacker_89_comment =
  "C++ Interface:\n"
  "releaseTexturePacker(TexturePacker tp)\n";
#else
static const char *Dtool_TexturePacker_releaseTexturePacker_89_comment = nullptr;
#endif

static int Dtool_Init_TexturePacker(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TexturePacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TexturePacker) {
    printf("TexturePacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TexturePacker *local_this = (TexturePacker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TexturePacker) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TexturePacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TexturePacker) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPFaceAttrib
 */
/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
 */
static PyObject *Dtool_BSPFaceAttrib_make_93(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1;
  static const char *keyword_list[] = {"face_material", "face_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    RenderAttrib const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str face_material, int face_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_93_comment =
  "C++ Interface:\n"
  "make(str face_material, int face_type)\n";
#else
static const char *Dtool_BSPFaceAttrib_make_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
 */
static PyObject *Dtool_BSPFaceAttrib_make_default_94(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_default(void)
  ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make_default();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_default_94_comment =
  "C++ Interface:\n"
  "make_default()\n";
#else
static const char *Dtool_BSPFaceAttrib_make_default_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_ignore_pvs(void)
 */
static PyObject *Dtool_BSPFaceAttrib_make_ignore_pvs_95(PyObject *, PyObject *) {
  // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make_ignore_pvs(void)
  ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make_ignore_pvs();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  RenderAttrib const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_RenderAttrib, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_make_ignore_pvs_95_comment =
  "C++ Interface:\n"
  "make_ignore_pvs()\n";
#else
static const char *Dtool_BSPFaceAttrib_make_ignore_pvs_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string BSPFaceAttrib::get_material(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_material_96(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline std::string BSPFaceAttrib::get_material(void) const
  std::string return_value = (*(const BSPFaceAttrib*)local_this).get_material();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_material_96_comment =
  "C++ Interface:\n"
  "get_material(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_material_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPFaceAttrib::get_face_type(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_face_type_97(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline int BSPFaceAttrib::get_face_type(void) const
  int return_value = (*(const BSPFaceAttrib*)local_this).get_face_type();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_face_type_97_comment =
  "C++ Interface:\n"
  "get_face_type(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_face_type_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPFaceAttrib::get_ignore_pvs(void) const
 */
static PyObject *Dtool_BSPFaceAttrib_get_ignore_pvs_98(PyObject *self, PyObject *) {
  BSPFaceAttrib *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPFaceAttrib)) {
    return nullptr;
  }
  // 1-inline bool BSPFaceAttrib::get_ignore_pvs(void) const
  bool return_value = (*(const BSPFaceAttrib*)local_this).get_ignore_pvs();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_ignore_pvs_98_comment =
  "C++ Interface:\n"
  "get_ignore_pvs(BSPFaceAttrib self)\n";
#else
static const char *Dtool_BSPFaceAttrib_get_ignore_pvs_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int BSPFaceAttrib::get_class_slot(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_slot_99(PyObject *, PyObject *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = BSPFaceAttrib::get_class_slot();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_slot_99_comment =
  "C++ Interface:\n"
  "get_class_slot()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_slot_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BSPFaceAttrib::get_class_type(void)
 */
static PyObject *Dtool_BSPFaceAttrib_get_class_type_101(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPFaceAttrib::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPFaceAttrib::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPFaceAttrib_get_class_type_101_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPFaceAttrib_get_class_type_101_comment = nullptr;
#endif

static PyObject *Dtool_BSPFaceAttrib_class_slot_Getter(PyObject *self, void *) {
  // 1-static int BSPFaceAttrib::get_class_slot(void)
  int return_value = BSPFaceAttrib::get_class_slot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_BSPFaceAttrib(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_BSPFaceAttrib(PyObject *args, CPT(BSPFaceAttrib) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPFaceAttrib)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-static ConstPointerTo< RenderAttrib > BSPFaceAttrib::make(std::string const &face_material, int face_type)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      int param1;
      if (PyArg_ParseTuple(args, "s#i:make", &param0_str, &param0_len, &param1)) {
        ConstPointerTo< RenderAttrib > return_value = BSPFaceAttrib::make(std::string(param0_str, param0_len), (int)param1);
        if (_PyErr_OCCURRED()) {
          return false;
        } else {
          coerced = std::move((BSPFaceAttrib const *) return_value.p());
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPFaceAttrib(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPFaceAttrib) {
    printf("BSPFaceAttrib ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPFaceAttrib *local_this = (BSPFaceAttrib *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPFaceAttrib) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_RenderAttrib) {
    return (RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(RenderAttrib *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPFaceAttrib(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPFaceAttrib) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_RenderAttrib) {
    RenderAttrib* other_this = (RenderAttrib*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPFaceAttrib*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPLoader
 */
/**
 * Python function wrapper for:
 * bool BSPLoader::read(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_read_105(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.read")) {
    return nullptr;
  }
  // 1-bool BSPLoader::read(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.read", "Filename");
  }
  bool return_value = (*local_this).read(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const BSPLoader self, const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_read_105_comment =
  "C++ Interface:\n"
  "read(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_read_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::do_optimizations(void)
 */
static PyObject *Dtool_BSPLoader_do_optimizations_106(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.do_optimizations")) {
    return nullptr;
  }
  // 1-void BSPLoader::do_optimizations(void)
  (*local_this).do_optimizations();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_do_optimizations_106_comment =
  "C++ Interface:\n"
  "do_optimizations(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_do_optimizations_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
 */
static PyObject *Dtool_BSPLoader_set_gamma_107(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_gamma")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_gamma(PN_stdfloat gamma, int overbright = 1)
  float param1;
  int param2 = 1;
  static const char *keyword_list[] = {"gamma", "overbright", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|i:set_gamma", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_gamma((PN_stdfloat)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gamma(const BSPLoader self, float gamma, int overbright)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_gamma_107_comment =
  "C++ Interface:\n"
  "set_gamma(const BSPLoader self, float gamma, int overbright)\n";
#else
static const char *Dtool_BSPLoader_set_gamma_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BSPLoader::get_gamma(void) const
 */
static PyObject *Dtool_BSPLoader_get_gamma_108(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat BSPLoader::get_gamma(void) const
  PN_stdfloat return_value = (*(const BSPLoader*)local_this).get_gamma();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_gamma_108_comment =
  "C++ Interface:\n"
  "get_gamma(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_gamma_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_win(GraphicsWindow *win)
 */
static PyObject *Dtool_BSPLoader_set_win_109(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_win")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_win(GraphicsWindow *win)
  GraphicsWindow *arg_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsWindow, 1, "BSPLoader.set_win", false, true);
  if (arg_this != nullptr) {
    (*local_this).set_win(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_win(const BSPLoader self, GraphicsWindow win)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_win_109_comment =
  "C++ Interface:\n"
  "set_win(const BSPLoader self, GraphicsWindow win)\n";
#else
static const char *Dtool_BSPLoader_set_win_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_camera(NodePath const &camera)
 */
static PyObject *Dtool_BSPLoader_set_camera_110(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_camera")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_camera", true, true);
  if (arg_this != nullptr) {
    (*local_this).set_camera(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera(const BSPLoader self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_camera_110_comment =
  "C++ Interface:\n"
  "set_camera(const BSPLoader self, const NodePath camera)\n";
#else
static const char *Dtool_BSPLoader_set_camera_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_render(NodePath const &render)
 */
static PyObject *Dtool_BSPLoader_set_render_111(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_render")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_render(NodePath const &render)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.set_render", true, true);
  if (arg_this != nullptr) {
    (*local_this).set_render(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render(const BSPLoader self, const NodePath render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_render_111_comment =
  "C++ Interface:\n"
  "set_render(const BSPLoader self, const NodePath render)\n";
#else
static const char *Dtool_BSPLoader_set_render_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_visibility(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_visibility_112(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_visibility")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_visibility(bool flag)
  (*local_this).set_want_visibility((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_visibility(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_visibility_112_comment =
  "C++ Interface:\n"
  "set_want_visibility(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_visibility_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_lightmaps(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_lightmaps_113(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_lightmaps")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_lightmaps(bool flag)
  (*local_this).set_want_lightmaps((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_lightmaps(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_lightmaps_113_comment =
  "C++ Interface:\n"
  "set_want_lightmaps(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_lightmaps_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_physics_type(int type)
 */
static PyObject *Dtool_BSPLoader_set_physics_type_114(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_physics_type")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_physics_type(int type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_physics_type((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_type(const BSPLoader self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_physics_type_114_comment =
  "C++ Interface:\n"
  "set_physics_type(const BSPLoader self, int type)\n";
#else
static const char *Dtool_BSPLoader_set_physics_type_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_visualize_leafs(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_visualize_leafs_115(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_visualize_leafs")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_visualize_leafs(bool flag)
  (*local_this).set_visualize_leafs((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visualize_leafs(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_visualize_leafs_115_comment =
  "C++ Interface:\n"
  "set_visualize_leafs(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_visualize_leafs_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_materials_file(Filename const &file)
 */
static PyObject *Dtool_BSPLoader_set_materials_file_116(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_materials_file")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_materials_file(Filename const &file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_materials_file", "Filename");
  }
  (*local_this).set_materials_file(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_materials_file(const BSPLoader self, const Filename file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_materials_file_116_comment =
  "C++ Interface:\n"
  "set_materials_file(const BSPLoader self, const Filename file)\n";
#else
static const char *Dtool_BSPLoader_set_materials_file_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_wireframe(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_wireframe_117(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_wireframe")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_wireframe(bool flag)
  (*local_this).set_wireframe((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wireframe(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_wireframe_117_comment =
  "C++ Interface:\n"
  "set_wireframe(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_wireframe_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::get_wireframe(void) const
 */
static PyObject *Dtool_BSPLoader_get_wireframe_118(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::get_wireframe(void) const
  bool return_value = (*(const BSPLoader*)local_this).get_wireframe();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_wireframe_118_comment =
  "C++ Interface:\n"
  "get_wireframe(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_wireframe_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BSPLoader::get_camera(void) const
 */
static PyObject *Dtool_BSPLoader_get_camera_119(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline NodePath BSPLoader::get_camera(void) const
  NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_camera());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_camera_119_comment =
  "C++ Interface:\n"
  "get_camera(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_camera_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::build_cubemaps(void)
 */
static PyObject *Dtool_BSPLoader_build_cubemaps_120(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.build_cubemaps")) {
    return nullptr;
  }
  // 1-void BSPLoader::build_cubemaps(void)
  (*local_this).build_cubemaps();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_build_cubemaps_120_comment =
  "C++ Interface:\n"
  "build_cubemaps(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_build_cubemaps_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::setup_shadowcam(void)
 */
static PyObject *Dtool_BSPLoader_setup_shadowcam_121(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.setup_shadowcam")) {
    return nullptr;
  }
  // 1-void BSPLoader::setup_shadowcam(void)
  (*local_this).setup_shadowcam();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_setup_shadowcam_121_comment =
  "C++ Interface:\n"
  "setup_shadowcam(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_setup_shadowcam_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::add_dynamic_node(NodePath const &node)
 */
static PyObject *Dtool_BSPLoader_add_dynamic_node_122(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.add_dynamic_node")) {
    return nullptr;
  }
  // 1-void BSPLoader::add_dynamic_node(NodePath const &node)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.add_dynamic_node", true, true);
  if (arg_this != nullptr) {
    (*local_this).add_dynamic_node(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dynamic_node(const BSPLoader self, const NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_add_dynamic_node_122_comment =
  "C++ Interface:\n"
  "add_dynamic_node(const BSPLoader self, const NodePath node)\n";
#else
static const char *Dtool_BSPLoader_add_dynamic_node_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_want_shadows(bool flag)
 */
static PyObject *Dtool_BSPLoader_set_want_shadows_123(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_want_shadows")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_want_shadows(bool flag)
  (*local_this).set_want_shadows((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_shadows(const BSPLoader self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_want_shadows_123_comment =
  "C++ Interface:\n"
  "set_want_shadows(const BSPLoader self, bool flag)\n";
#else
static const char *Dtool_BSPLoader_set_want_shadows_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shadow_cam_pos(LPoint3 const &pos)
 */
static PyObject *Dtool_BSPLoader_set_shadow_cam_pos_124(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shadow_cam_pos")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shadow_cam_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_shadow_cam_pos", "LPoint3f");
  }
  (*local_this).set_shadow_cam_pos(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_cam_pos(const BSPLoader self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shadow_cam_pos_124_comment =
  "C++ Interface:\n"
  "set_shadow_cam_pos(const BSPLoader self, const LPoint3f pos)\n";
#else
static const char *Dtool_BSPLoader_set_shadow_cam_pos_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shadow_cam_bitmask(BitMask32 const &mask)
 */
static PyObject *Dtool_BSPLoader_set_shadow_cam_bitmask_125(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shadow_cam_bitmask")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shadow_cam_bitmask(BitMask32 const &mask)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_shadow_cam_bitmask", "BitMask");
  }
  (*local_this).set_shadow_cam_bitmask(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_cam_bitmask(const BSPLoader self, const BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shadow_cam_bitmask_125_comment =
  "C++ Interface:\n"
  "set_shadow_cam_bitmask(const BSPLoader self, const BitMask mask)\n";
#else
static const char *Dtool_BSPLoader_set_shadow_cam_bitmask_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shadow_color(LColor const &color)
 */
static PyObject *Dtool_BSPLoader_set_shadow_color_126(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shadow_color")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shadow_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.set_shadow_color", "LVecBase4f");
  }
  (*local_this).set_shadow_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_color(const BSPLoader self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shadow_color_126_comment =
  "C++ Interface:\n"
  "set_shadow_color(const BSPLoader self, const LVecBase4f color)\n";
#else
static const char *Dtool_BSPLoader_set_shadow_color_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_shadow_resolution(int filmsize, int texsize)
 */
static PyObject *Dtool_BSPLoader_set_shadow_resolution_127(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_shadow_resolution")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_shadow_resolution(int filmsize, int texsize)
  int param1;
  int param2;
  static const char *keyword_list[] = {"filmsize", "texsize", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_shadow_resolution", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_shadow_resolution((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_resolution(const BSPLoader self, int filmsize, int texsize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_shadow_resolution_127_comment =
  "C++ Interface:\n"
  "set_shadow_resolution(const BSPLoader self, int filmsize, int texsize)\n";
#else
static const char *Dtool_BSPLoader_set_shadow_resolution_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cast_shadows(NodePath &node)
 */
static PyObject *Dtool_BSPLoader_cast_shadows_128(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cast_shadows")) {
    return nullptr;
  }
  // 1-void BSPLoader::cast_shadows(NodePath &node)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.cast_shadows", false, true);
  if (arg_this != nullptr) {
    (*local_this).cast_shadows(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cast_shadows(const BSPLoader self, NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cast_shadows_128_comment =
  "C++ Interface:\n"
  "cast_shadows(const BSPLoader self, NodePath node)\n";
#else
static const char *Dtool_BSPLoader_cast_shadows_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *BSPLoader::get_shadow_tex(void) const
 */
static PyObject *Dtool_BSPLoader_get_shadow_tex_129(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-Texture *BSPLoader::get_shadow_tex(void) const
  Texture *return_value = (*(const BSPLoader*)local_this).get_shadow_tex();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_shadow_tex_129_comment =
  "C++ Interface:\n"
  "get_shadow_tex(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_shadow_tex_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::extract_modelnum(int entnum)
 */
static PyObject *Dtool_BSPLoader_extract_modelnum_130(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.extract_modelnum")) {
    return nullptr;
  }
  // 1-inline int BSPLoader::extract_modelnum(int entnum)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).extract_modelnum((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_modelnum(const BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_extract_modelnum_130_comment =
  "C++ Interface:\n"
  "extract_modelnum(const BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_extract_modelnum_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BSPLoader::get_model_bounds(int modelnum, LPoint3 &mins, LPoint3 &maxs)
 */
static PyObject *Dtool_BSPLoader_get_model_bounds_131(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_model_bounds")) {
    return nullptr;
  }
  // 1-inline void BSPLoader::get_model_bounds(int modelnum, LPoint3 &mins, LPoint3 &maxs)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"modelnum", "mins", "maxs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:get_model_bounds", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.get_model_bounds", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3 *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "BSPLoader.get_model_bounds", "LPoint3f");
    }
    (*local_this).get_model_bounds((int)param1, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model_bounds(const BSPLoader self, int modelnum, LPoint3f mins, LPoint3f maxs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_bounds_131_comment =
  "C++ Interface:\n"
  "get_model_bounds(const BSPLoader self, int modelnum, LPoint3f mins, LPoint3f maxs)\n";
#else
static const char *Dtool_BSPLoader_get_model_bounds_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_server_entity_dispatcher(PyObject *dispatcher)
 */
static PyObject *Dtool_BSPLoader_set_server_entity_dispatcher_132(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_server_entity_dispatcher")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_server_entity_dispatcher(PyObject *dispatcher)
  (*local_this).set_server_entity_dispatcher(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_entity_dispatcher(const BSPLoader self, object dispatcher)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_server_entity_dispatcher_132_comment =
  "C++ Interface:\n"
  "set_server_entity_dispatcher(const BSPLoader self, object dispatcher)\n";
#else
static const char *Dtool_BSPLoader_set_server_entity_dispatcher_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::link_server_entity_to_class(std::string const &name, PyTypeObject *type)
 */
static PyObject *Dtool_BSPLoader_link_server_entity_to_class_133(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.link_server_entity_to_class")) {
    return nullptr;
  }
  // 1-void BSPLoader::link_server_entity_to_class(std::string const &name, PyTypeObject *type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:link_server_entity_to_class", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    if (PyType_Check(param2)) {
      (*local_this).link_server_entity_to_class(std::string(param1_str, param1_len), (PyTypeObject *)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_server_entity_to_class(const BSPLoader self, str name, type type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_link_server_entity_to_class_133_comment =
  "C++ Interface:\n"
  "link_server_entity_to_class(const BSPLoader self, str name, type type)\n";
#else
static const char *Dtool_BSPLoader_link_server_entity_to_class_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::set_ai(bool ai)
 */
static PyObject *Dtool_BSPLoader_set_ai_134(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.set_ai")) {
    return nullptr;
  }
  // 1-void BSPLoader::set_ai(bool ai)
  (*local_this).set_ai((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ai(const BSPLoader self, bool ai)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_set_ai_134_comment =
  "C++ Interface:\n"
  "set_ai(const BSPLoader self, bool ai)\n";
#else
static const char *Dtool_BSPLoader_set_ai_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::is_ai(void) const
 */
static PyObject *Dtool_BSPLoader_is_ai_135(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::is_ai(void) const
  bool return_value = (*(const BSPLoader*)local_this).is_ai();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_is_ai_135_comment =
  "C++ Interface:\n"
  "is_ai(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_is_ai_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::update_dynamic_node(NodePath const &node)
 */
static PyObject *Dtool_BSPLoader_update_dynamic_node_136(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.update_dynamic_node")) {
    return nullptr;
  }
  // 1-void BSPLoader::update_dynamic_node(NodePath const &node)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "BSPLoader.update_dynamic_node", true, true);
  if (arg_this != nullptr) {
    (*local_this).update_dynamic_node(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_dynamic_node(const BSPLoader self, const NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_update_dynamic_node_136_comment =
  "C++ Interface:\n"
  "update_dynamic_node(const BSPLoader self, const NodePath node)\n";
#else
static const char *Dtool_BSPLoader_update_dynamic_node_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BSPLoader::trace_line(LPoint3 const &start, LPoint3 const &end)
 */
static PyObject *Dtool_BSPLoader_trace_line_137(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.trace_line")) {
    return nullptr;
  }
  // 1-bool BSPLoader::trace_line(LPoint3 const &start, LPoint3 const &end)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"start", "end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:trace_line", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BSPLoader.trace_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BSPLoader.trace_line", "LPoint3f");
    }
    bool return_value = (*local_this).trace_line(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trace_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_trace_line_137_comment =
  "C++ Interface:\n"
  "trace_line(const BSPLoader self, const LPoint3f start, const LPoint3f end)\n";
#else
static const char *Dtool_BSPLoader_trace_line_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
 */
static PyObject *Dtool_BSPLoader_link_entity_to_class_138(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.link_entity_to_class")) {
    return nullptr;
  }
  // 1-void BSPLoader::link_entity_to_class(std::string const &entname, PyTypeObject *type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"entname", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:link_entity_to_class", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    if (PyType_Check(param2)) {
      (*local_this).link_entity_to_class(std::string(param1_str, param1_len), (PyTypeObject *)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_entity_to_class(const BSPLoader self, str entname, type type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_link_entity_to_class_138_comment =
  "C++ Interface:\n"
  "link_entity_to_class(const BSPLoader self, str entname, type type)\n";
#else
static const char *Dtool_BSPLoader_link_entity_to_class_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
 */
static PyObject *Dtool_BSPLoader_get_py_entity_by_target_name_139(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-PyObject *BSPLoader::get_py_entity_by_target_name(std::string const &targetname) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PyObject *return_value = (*(const BSPLoader*)local_this).get_py_entity_by_target_name(std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_py_entity_by_target_name(BSPLoader self, str targetname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_py_entity_by_target_name_139_comment =
  "C++ Interface:\n"
  "get_py_entity_by_target_name(BSPLoader self, str targetname)\n";
#else
static const char *Dtool_BSPLoader_get_py_entity_by_target_name_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *BSPLoader::find_all_entities(std::string const &classname)
 */
static PyObject *Dtool_BSPLoader_find_all_entities_140(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_all_entities")) {
    return nullptr;
  }
  // 1-PyObject *BSPLoader::find_all_entities(std::string const &classname)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PyObject *return_value = (*local_this).find_all_entities(std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_entities(const BSPLoader self, str classname)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_all_entities_140_comment =
  "C++ Interface:\n"
  "find_all_entities(const BSPLoader self, str classname)\n";
#else
static const char *Dtool_BSPLoader_find_all_entities_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::get_entity_keyvalues(PyObject *list, int const entnum)
 */
static PyObject *Dtool_BSPLoader_get_entity_keyvalues_141(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.get_entity_keyvalues")) {
    return nullptr;
  }
  // 1-void BSPLoader::get_entity_keyvalues(PyObject *list, int const entnum)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"list", "entnum", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_entity_keyvalues", (char **)keyword_list, &param1, &param2)) {
    (*local_this).get_entity_keyvalues(param1, (int const)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_keyvalues(const BSPLoader self, object list, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_keyvalues_141_comment =
  "C++ Interface:\n"
  "get_entity_keyvalues(const BSPLoader self, object list, int entnum)\n";
#else
static const char *Dtool_BSPLoader_get_entity_keyvalues_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::link_cent_to_pyent(int entum, PyObject *pyent)
 */
static PyObject *Dtool_BSPLoader_link_cent_to_pyent_142(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.link_cent_to_pyent")) {
    return nullptr;
  }
  // 1-void BSPLoader::link_cent_to_pyent(int entum, PyObject *pyent)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"entum", "pyent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:link_cent_to_pyent", (char **)keyword_list, &param1, &param2)) {
    (*local_this).link_cent_to_pyent((int)param1, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "link_cent_to_pyent(const BSPLoader self, int entum, object pyent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_link_cent_to_pyent_142_comment =
  "C++ Interface:\n"
  "link_cent_to_pyent(const BSPLoader self, int entum, object pyent)\n";
#else
static const char *Dtool_BSPLoader_link_cent_to_pyent_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_num_entities(void) const
 */
static PyObject *Dtool_BSPLoader_get_num_entities_143(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-int BSPLoader::get_num_entities(void) const
  int return_value = (*(const BSPLoader*)local_this).get_num_entities();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_num_entities_143_comment =
  "C++ Interface:\n"
  "get_num_entities(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_num_entities_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string BSPLoader::get_entity_value(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_144(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-std::string BSPLoader::get_entity_value(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value", (char **)keyword_list, &param1, &param2)) {
    std::string return_value = (*(const BSPLoader*)local_this).get_entity_value((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_144_comment =
  "C++ Interface:\n"
  "get_entity_value(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float BSPLoader::get_entity_value_float(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_float_145(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-float BSPLoader::get_entity_value_float(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_float", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const BSPLoader*)local_this).get_entity_value_float((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_float(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_float_145_comment =
  "C++ Interface:\n"
  "get_entity_value_float(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_float_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BSPLoader::get_entity_value_int(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_int_146(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-int BSPLoader::get_entity_value_int(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_int", (char **)keyword_list, &param1, &param2)) {
    int return_value = (*(const BSPLoader*)local_this).get_entity_value_int((int)param1, (char const *)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_int(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_int_146_comment =
  "C++ Interface:\n"
  "get_entity_value_int(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_int_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_vector_147(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-LVector3 BSPLoader::get_entity_value_vector(int entnum, char const *key) const
  int param1;
  char const *param2;
  static const char *keyword_list[] = {"entnum", "key", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz:get_entity_value_vector", (char **)keyword_list, &param1, &param2)) {
    LVector3 *return_value = new LVector3((*(const BSPLoader*)local_this).get_entity_value_vector((int)param1, (char const *)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_vector(BSPLoader self, int entnum, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_vector_147_comment =
  "C++ Interface:\n"
  "get_entity_value_vector(BSPLoader self, int entnum, str key)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_vector_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
 */
static PyObject *Dtool_BSPLoader_get_entity_value_color_148(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-LColor BSPLoader::get_entity_value_color(int entnum, char const *key, bool scale = true) const
  int param1;
  char const *param2;
  PyObject *param3 = Py_True;
  static const char *keyword_list[] = {"entnum", "key", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iz|O:get_entity_value_color", (char **)keyword_list, &param1, &param2, &param3)) {
    LColor *return_value = new LColor((*(const BSPLoader*)local_this).get_entity_value_color((int)param1, (char const *)param2, (PyObject_IsTrue(param3) != 0)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_value_color_148_comment =
  "C++ Interface:\n"
  "get_entity_value_color(BSPLoader self, int entnum, str key, bool scale)\n";
#else
static const char *Dtool_BSPLoader_get_entity_value_color_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_entity(int entnum) const
 */
static PyObject *Dtool_BSPLoader_get_entity_149(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_entity(int entnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_entity((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entity(BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_entity_149_comment =
  "C++ Interface:\n"
  "get_entity(BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_get_entity_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_model(int modelnum) const
 */
static PyObject *Dtool_BSPLoader_get_model_150(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_model(int modelnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_model((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_model(BSPLoader self, int modelnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_model_150_comment =
  "C++ Interface:\n"
  "get_model(BSPLoader self, int modelnum)\n";
#else
static const char *Dtool_BSPLoader_get_model_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CBaseEntity *BSPLoader::get_c_entity(int const entnum) const
 */
static PyObject *Dtool_BSPLoader_get_c_entity_151(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline CBaseEntity *BSPLoader::get_c_entity(int const entnum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CBaseEntity *return_value = (*(const BSPLoader*)local_this).get_c_entity((int const)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CBaseEntity, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_entity(BSPLoader self, int entnum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_c_entity_151_comment =
  "C++ Interface:\n"
  "get_c_entity(BSPLoader self, int entnum)\n";
#else
static const char *Dtool_BSPLoader_get_c_entity_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::find_leaf(LPoint3 const &pos)
 * inline int BSPLoader::find_leaf(NodePath const &np)
 */
static PyObject *Dtool_BSPLoader_find_leaf_152(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_leaf")) {
    return nullptr;
  }
  {
    // -2 inline int BSPLoader::find_leaf(LPoint3 const &pos)
    LPoint3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint3f);
    if (arg_this != nullptr) {
      int return_value = (*local_this).find_leaf(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int BSPLoader::find_leaf(NodePath const &np)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      int return_value = (*local_this).find_leaf(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int BSPLoader::find_leaf(LPoint3 const &pos)
    LPoint3f arg_local;
    LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      int return_value = (*local_this).find_leaf(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int BSPLoader::find_leaf(NodePath const &np)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_leaf(const BSPLoader self, const LPoint3f pos)\n"
      "find_leaf(const BSPLoader self, const NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_leaf_152_comment =
  "C++ Interface:\n"
  "find_leaf(const BSPLoader self, const LPoint3f pos)\n"
  "find_leaf(const BSPLoader self, const NodePath np)\n";
#else
static const char *Dtool_BSPLoader_find_leaf_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BSPLoader::find_node(LPoint3 const &pos)
 */
static PyObject *Dtool_BSPLoader_find_node_153(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.find_node")) {
    return nullptr;
  }
  // 1-inline int BSPLoader::find_node(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BSPLoader.find_node", "LPoint3f");
  }
  int return_value = (*local_this).find_node(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_node(const BSPLoader self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_find_node_153_comment =
  "C++ Interface:\n"
  "find_node(const BSPLoader self, const LPoint3f pos)\n";
#else
static const char *Dtool_BSPLoader_find_node_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::is_cluster_visible(int curr_cluster, int cluster) const
 */
static PyObject *Dtool_BSPLoader_is_cluster_visible_154(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::is_cluster_visible(int curr_cluster, int cluster) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"curr_cluster", "cluster", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:is_cluster_visible", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const BSPLoader*)local_this).is_cluster_visible((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_cluster_visible(BSPLoader self, int curr_cluster, int cluster)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_is_cluster_visible_154_comment =
  "C++ Interface:\n"
  "is_cluster_visible(BSPLoader self, int curr_cluster, int cluster)\n";
#else
static const char *Dtool_BSPLoader_is_cluster_visible_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::pvs_bounds_test(GeometricBoundingVolume const *bounds)
 */
static PyObject *Dtool_BSPLoader_pvs_bounds_test_155(PyObject *self, PyObject *arg) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.pvs_bounds_test")) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::pvs_bounds_test(GeometricBoundingVolume const *bounds)
  GeometricBoundingVolume const *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "BSPLoader.pvs_bounds_test", true, true);
  if (arg_this != nullptr) {
    bool return_value = (*local_this).pvs_bounds_test(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pvs_bounds_test(const BSPLoader self, const GeometricBoundingVolume bounds)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_pvs_bounds_test_155_comment =
  "C++ Interface:\n"
  "pvs_bounds_test(const BSPLoader self, const GeometricBoundingVolume bounds)\n";
#else
static const char *Dtool_BSPLoader_pvs_bounds_test_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< GeometricBoundingVolume > BSPLoader::make_net_bounds(TransformState const *net_transform, GeometricBoundingVolume const *original)
 */
static PyObject *Dtool_BSPLoader_make_net_bounds_156(PyObject *self, PyObject *args, PyObject *kwds) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.make_net_bounds")) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< GeometricBoundingVolume > BSPLoader::make_net_bounds(TransformState const *net_transform, GeometricBoundingVolume const *original)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"net_transform", "original", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_net_bounds", (char **)keyword_list, &param1, &param2)) {
    TransformState const *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TransformState, 1, "BSPLoader.make_net_bounds", true, true);
    GeometricBoundingVolume const *param2_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GeometricBoundingVolume, 2, "BSPLoader.make_net_bounds", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ConstPointerTo< GeometricBoundingVolume > return_value = (*local_this).make_net_bounds(param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GeometricBoundingVolume const *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_net_bounds(const BSPLoader self, const TransformState net_transform, const GeometricBoundingVolume original)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_make_net_bounds_156_comment =
  "C++ Interface:\n"
  "make_net_bounds(const BSPLoader self, const TransformState net_transform, const GeometricBoundingVolume original)\n";
#else
static const char *Dtool_BSPLoader_make_net_bounds_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_active_level(void) const
 */
static PyObject *Dtool_BSPLoader_has_active_level_157(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_active_level(void) const
  bool return_value = (*(const BSPLoader*)local_this).has_active_level();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_active_level_157_comment =
  "C++ Interface:\n"
  "has_active_level(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_has_active_level_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BSPLoader::has_visibility(void) const
 */
static PyObject *Dtool_BSPLoader_has_visibility_158(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-inline bool BSPLoader::has_visibility(void) const
  bool return_value = (*(const BSPLoader*)local_this).has_visibility();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_has_visibility_158_comment =
  "C++ Interface:\n"
  "has_visibility(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_has_visibility_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BSPLoader::cleanup(void)
 */
static PyObject *Dtool_BSPLoader_cleanup_159(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BSPLoader, (void **)&local_this, "BSPLoader.cleanup")) {
    return nullptr;
  }
  // 1-void BSPLoader::cleanup(void)
  (*local_this).cleanup();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_cleanup_159_comment =
  "C++ Interface:\n"
  "cleanup(const BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_cleanup_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath BSPLoader::get_result(void) const
 */
static PyObject *Dtool_BSPLoader_get_result_160(PyObject *self, PyObject *) {
  BSPLoader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BSPLoader)) {
    return nullptr;
  }
  // 1-NodePath BSPLoader::get_result(void) const
  NodePath *return_value = new NodePath((*(const BSPLoader*)local_this).get_result());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_result_160_comment =
  "C++ Interface:\n"
  "get_result(BSPLoader self)\n";
#else
static const char *Dtool_BSPLoader_get_result_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static BSPLoader *BSPLoader::get_global_ptr(void)
 */
static PyObject *Dtool_BSPLoader_get_global_ptr_161(PyObject *, PyObject *) {
  // 1-static BSPLoader *BSPLoader::get_global_ptr(void)
  BSPLoader *return_value = BSPLoader::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BSPLoader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPLoader_get_global_ptr_161_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_BSPLoader_get_global_ptr_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * BSPLoader::BSPLoader(void)
 */
static int Dtool_Init_BSPLoader(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BSPLoader() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPLoader() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-BSPLoader::BSPLoader(void)
  BSPLoader *return_value = new BSPLoader();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPLoader, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPLoader()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BSPLoader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPLoader) {
    printf("BSPLoader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPLoader *local_this = (BSPLoader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPLoader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPLoader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPLoader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPCullTraverser
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPCullTraverser::get_class_type(void)
 */
static PyObject *Dtool_BSPCullTraverser_get_class_type_166(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPCullTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPCullTraverser::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPCullTraverser_get_class_type_166_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPCullTraverser_get_class_type_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPCullTraverser::BSPCullTraverser(BSPCullTraverser const &) = default
 * BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
 */
static int Dtool_Init_BSPCullTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPCullTraverser::BSPCullTraverser(BSPCullTraverser const &) = default
      CPT(BSPCullTraverser) arg_this;
      if (!Dtool_ConstCoerce_BSPCullTraverser(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BSPCullTraverser.BSPCullTraverser", "BSPCullTraverser");
        return -1;
      }
      BSPCullTraverser *return_value = new BSPCullTraverser(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPCullTraverser, true, false);
    }
    break;
  case 2:
    {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"trav", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BSPCullTraverser", (char **)keyword_list, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, true);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPCullTraverser, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPCullTraverser() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPCullTraverser(const BSPCullTraverser param0)\n"
      "BSPCullTraverser(CullTraverser trav, BSPLoader loader)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPCullTraverser(PyObject *args, CPT(BSPCullTraverser) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPCullTraverser)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BSPCullTraverser", 2, 2, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, false);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, false);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BSPCullTraverser(PyObject *args, PT(BSPCullTraverser) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPCullTraverser)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPCullTraverser::BSPCullTraverser(CullTraverser *trav, BSPLoader *loader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "BSPCullTraverser", 2, 2, &param0, &param1)) {
        CullTraverser *param0_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CullTraverser, 0, "BSPCullTraverser.BSPCullTraverser", false, false);
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPCullTraverser.BSPCullTraverser", false, false);
        if (param0_this != nullptr && param1_this != nullptr) {
          BSPCullTraverser *return_value = new BSPCullTraverser(param0_this, param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPCullTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPCullTraverser) {
    printf("BSPCullTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPCullTraverser *local_this = (BSPCullTraverser *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPCullTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CullTraverser) {
    return (CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CullTraverser *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CullTraverser *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPCullTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPCullTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CullTraverser) {
    CullTraverser* other_this = (CullTraverser*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BSPCullTraverser*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPRender
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPRender::get_class_type(void)
 */
static PyObject *Dtool_BSPRender_get_class_type_171(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPRender::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPRender::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPRender_get_class_type_171_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPRender_get_class_type_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPRender::BSPRender(BSPRender const &) = default
 * BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
 */
static int Dtool_Init_BSPRender(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BSPRender::BSPRender(BSPRender const &) = default
      CPT(BSPRender) arg_this;
      if (!Dtool_ConstCoerce_BSPRender(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "BSPRender.BSPRender", "BSPRender");
        return -1;
      }
      BSPRender *return_value = new BSPRender(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRender, true, false);
    }
    break;
  case 2:
    {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "loader", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:BSPRender", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, true);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRender, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BSPRender() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPRender(const BSPRender param0)\n"
      "BSPRender(str name, BSPLoader loader)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPRender(PyObject *args, CPT(BSPRender) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRender)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:BSPRender", &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, false);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_BSPRender(PyObject *args, PT(BSPRender) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRender)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-BSPRender::BSPRender(std::string const &name, BSPLoader *loader)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      if (PyArg_ParseTuple(args, "s#O:BSPRender", &param0_str, &param0_len, &param1)) {
        BSPLoader *param1_this = (BSPLoader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BSPLoader, 1, "BSPRender.BSPRender", false, false);
        if (param1_this != nullptr) {
          BSPRender *return_value = new BSPRender(std::string(param0_str, param0_len), param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_BSPRender(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPRender) {
    printf("BSPRender ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPRender *local_this = (BSPRender *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPRender) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPRender(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPRender) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPRender*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPRender*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPRoot
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPRoot::get_class_type(void)
 */
static PyObject *Dtool_BSPRoot_get_class_type_175(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPRoot::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPRoot::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPRoot_get_class_type_175_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPRoot_get_class_type_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPRoot::BSPRoot(BSPRoot const &) = default
 * BSPRoot::BSPRoot(std::string const &name)
 */
static int Dtool_Init_BSPRoot(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPRoot() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPRoot::BSPRoot(BSPRoot const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPRoot const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPRoot);
      if (param0_this != nullptr) {
        BSPRoot *return_value = new BSPRoot(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
      }
    }
  }

  {
    // -2 BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPRoot", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPRoot::BSPRoot(BSPRoot const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPRoot) param0_this;
      if (Dtool_ConstCoerce_BSPRoot(param0, param0_this)) {
        BSPRoot *return_value = new BSPRoot(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPRoot, true, false);
      }
    }
  }

  // No coercion possible: BSPRoot::BSPRoot(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPRoot(const BSPRoot param0)\n"
      "BSPRoot(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPRoot(PyObject *args, CPT(BSPRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRoot)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPRoot(PyObject *args, PT(BSPRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPRoot)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPRoot::BSPRoot(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPRoot *return_value = new BSPRoot(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPRoot) {
    printf("BSPRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPRoot *local_this = (BSPRoot *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPRoot) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPRoot) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPRoot*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPRoot*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPProp
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPProp::get_class_type(void)
 */
static PyObject *Dtool_BSPProp_get_class_type_180(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPProp::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPProp::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPProp_get_class_type_180_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPProp_get_class_type_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPProp::BSPProp(BSPProp const &) = default
 * BSPProp::BSPProp(std::string const &name)
 */
static int Dtool_Init_BSPProp(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPProp() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPProp::BSPProp(BSPProp const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPProp const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPProp);
      if (param0_this != nullptr) {
        BSPProp *return_value = new BSPProp(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
      }
    }
  }

  {
    // -2 BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPProp", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPProp::BSPProp(BSPProp const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPProp) param0_this;
      if (Dtool_ConstCoerce_BSPProp(param0, param0_this)) {
        BSPProp *return_value = new BSPProp(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPProp, true, false);
      }
    }
  }

  // No coercion possible: BSPProp::BSPProp(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPProp(const BSPProp param0)\n"
      "BSPProp(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPProp(PyObject *args, CPT(BSPProp) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPProp)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPProp(PyObject *args, PT(BSPProp) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPProp)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPProp::BSPProp(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPProp *return_value = new BSPProp(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPProp(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPProp) {
    printf("BSPProp ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPProp *local_this = (BSPProp *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPProp) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ModelNode) {
    return (ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPProp(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPProp) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    ModelNode* other_this = (ModelNode*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPProp*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPProp*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BSPModel
 */
/**
 * Python function wrapper for:
 * static TypeHandle BSPModel::get_class_type(void)
 */
static PyObject *Dtool_BSPModel_get_class_type_184(PyObject *, PyObject *) {
  // 1-static TypeHandle BSPModel::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(BSPModel::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BSPModel_get_class_type_184_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BSPModel_get_class_type_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BSPModel::BSPModel(BSPModel const &) = default
 * BSPModel::BSPModel(std::string const &name)
 */
static int Dtool_Init_BSPModel(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BSPModel() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline BSPModel::BSPModel(BSPModel const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      BSPModel const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BSPModel);
      if (param0_this != nullptr) {
        BSPModel *return_value = new BSPModel(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
      }
    }
  }

  {
    // -2 BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:BSPModel", (char **)keyword_list, &param0_str, &param0_len)) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline BSPModel::BSPModel(BSPModel const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(BSPModel) param0_this;
      if (Dtool_ConstCoerce_BSPModel(param0, param0_this)) {
        BSPModel *return_value = new BSPModel(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BSPModel, true, false);
      }
    }
  }

  // No coercion possible: BSPModel::BSPModel(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BSPModel(const BSPModel param0)\n"
      "BSPModel(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BSPModel(PyObject *args, CPT(BSPModel) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPModel)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_BSPModel(PyObject *args, PT(BSPModel) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BSPModel)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-BSPModel::BSPModel(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      BSPModel *return_value = new BSPModel(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_BSPModel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BSPModel) {
    printf("BSPModel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BSPModel *local_this = (BSPModel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BSPModel) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ModelNode) {
    return (ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(ModelNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BSPModel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BSPModel) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ModelNode) {
    ModelNode* other_this = (ModelNode*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BSPModel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BSPModel*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderPermutations
 */
/**
 * Python function wrapper for:
 * void ShaderPermutations::add_permutation(std::string const &key, std::string const &value = "1")
 */
static PyObject *Dtool_ShaderPermutations_add_permutation_188(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_permutation")) {
    return nullptr;
  }
  // 1-void ShaderPermutations::add_permutation(std::string const &key, std::string const &value = "1")
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = "1";
  Py_ssize_t param2_len = 1;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:add_permutation", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    (*local_this).add_permutation(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_permutation(const ShaderPermutations self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_permutation_188_comment =
  "C++ Interface:\n"
  "add_permutation(const ShaderPermutations self, str key, str value)\n";
#else
static const char *Dtool_ShaderPermutations_add_permutation_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShaderPermutations::add_input(ShaderInput const &inp, bool important = true)
 */
static PyObject *Dtool_ShaderPermutations_add_input_189(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_input")) {
    return nullptr;
  }
  // 1-void ShaderPermutations::add_input(ShaderInput const &inp, bool important = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"inp", "important", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:add_input", (char **)keyword_list, &param1, &param2)) {
    ShaderInput const *param1_this = (ShaderInput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ShaderInput, 1, "ShaderPermutations.add_input", true, true);
    if (param1_this != nullptr) {
      (*local_this).add_input(*param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_input(const ShaderPermutations self, const ShaderInput inp, bool important)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_input_189_comment =
  "C++ Interface:\n"
  "add_input(const ShaderPermutations self, const ShaderInput inp, bool important)\n";
#else
static const char *Dtool_ShaderPermutations_add_input_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShaderPermutations::add_flag(int flag)
 */
static PyObject *Dtool_ShaderPermutations_add_flag_190(PyObject *self, PyObject *arg) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderPermutations, (void **)&local_this, "ShaderPermutations.add_flag")) {
    return nullptr;
  }
  // 1-void ShaderPermutations::add_flag(int flag)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_flag((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flag(const ShaderPermutations self, int flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderPermutations_add_flag_190_comment =
  "C++ Interface:\n"
  "add_flag(const ShaderPermutations self, int flag)\n";
#else
static const char *Dtool_ShaderPermutations_add_flag_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShaderPermutations::ShaderPermutations(void) = default
 * inline ShaderPermutations::ShaderPermutations(ShaderPermutations const &) = default
 */
static int Dtool_Init_ShaderPermutations(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ShaderPermutations() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ShaderPermutations::ShaderPermutations(void) = default
      ShaderPermutations *return_value = new ShaderPermutations();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderPermutations, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ShaderPermutations::ShaderPermutations(ShaderPermutations const &) = default
      ShaderPermutations const *arg_this = (ShaderPermutations *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShaderPermutations, 0, "ShaderPermutations.ShaderPermutations", true, true);
      if (arg_this != nullptr) {
        ShaderPermutations *return_value = new ShaderPermutations(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShaderPermutations, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShaderPermutations() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShaderPermutations()\n"
      "ShaderPermutations(const ShaderPermutations param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShaderPermutations(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderPermutations) {
    printf("ShaderPermutations ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderPermutations *local_this = (ShaderPermutations *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderPermutations) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderPermutations(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderPermutations) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShaderSpec
 */
/**
 * Python function wrapper for:
 * void ShaderSpec::read_shader_files(Filename const &vert_file, Filename const &pixel_file, Filename const &geom_file)
 */
static PyObject *Dtool_ShaderSpec_read_shader_files_201(PyObject *self, PyObject *args, PyObject *kwds) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.read_shader_files")) {
    return nullptr;
  }
  // 1-void ShaderSpec::read_shader_files(Filename const &vert_file, Filename const &pixel_file, Filename const &geom_file)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"vert_file", "pixel_file", "geom_file", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:read_shader_files", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ShaderSpec.read_shader_files", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ShaderSpec.read_shader_files", "Filename");
    }
    Filename param3_local;
    Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "ShaderSpec.read_shader_files", "Filename");
    }
    (*local_this).read_shader_files(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_shader_files(const ShaderSpec self, const Filename vert_file, const Filename pixel_file, const Filename geom_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_read_shader_files_201_comment =
  "C++ Interface:\n"
  "read_shader_files(const ShaderSpec self, const Filename vert_file, const Filename pixel_file, const Filename geom_file)\n";
#else
static const char *Dtool_ShaderSpec_read_shader_files_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ShaderSpec::get_class_type(void)
 */
static PyObject *Dtool_ShaderSpec_get_class_type_202(PyObject *, PyObject *) {
  // 1-static TypeHandle ShaderSpec::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ShaderSpec::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_get_class_type_202_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShaderSpec_get_class_type_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *ShaderSpec::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_ShaderSpec_upcast_to_ReferenceCount_196(PyObject *self, PyObject *) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *ShaderSpec::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_upcast_to_ReferenceCount_196_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const ShaderSpec self)\n"
  "\n"
  "upcast from ShaderSpec to ReferenceCount";
#else
static const char *Dtool_ShaderSpec_upcast_to_ReferenceCount_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *ShaderSpec::upcast_to_Namable(void)
 */
static PyObject *Dtool_ShaderSpec_upcast_to_Namable_199(PyObject *self, PyObject *) {
  ShaderSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShaderSpec, (void **)&local_this, "ShaderSpec.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *ShaderSpec::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ShaderSpec_upcast_to_Namable_199_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const ShaderSpec self)\n"
  "\n"
  "upcast from ShaderSpec to Namable";
#else
static const char *Dtool_ShaderSpec_upcast_to_Namable_199_comment = nullptr;
#endif

static int Dtool_Init_ShaderSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_ShaderSpec(PyObject *args, CPT(ShaderSpec) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderSpec)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_ShaderSpec(PyObject *args, PT(ShaderSpec) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ShaderSpec)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShaderSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShaderSpec) {
    printf("ShaderSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShaderSpec *local_this = (ShaderSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShaderSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShaderSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ShaderSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShaderSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PSSMShaderGenerator
 */
/**
 * Python function wrapper for:
 * void PSSMShaderGenerator::set_sun_light(NodePath const &np)
 */
static PyObject *Dtool_PSSMShaderGenerator_set_sun_light_207(PyObject *self, PyObject *arg) {
  PSSMShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMShaderGenerator, (void **)&local_this, "PSSMShaderGenerator.set_sun_light")) {
    return nullptr;
  }
  // 1-void PSSMShaderGenerator::set_sun_light(NodePath const &np)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PSSMShaderGenerator.set_sun_light", true, true);
  if (arg_this != nullptr) {
    (*local_this).set_sun_light(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sun_light(const PSSMShaderGenerator self, const NodePath np)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_set_sun_light_207_comment =
  "C++ Interface:\n"
  "set_sun_light(const PSSMShaderGenerator self, const NodePath np)\n";
#else
static const char *Dtool_PSSMShaderGenerator_set_sun_light_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PSSMShaderGenerator::start_update(void)
 */
static PyObject *Dtool_PSSMShaderGenerator_start_update_208(PyObject *self, PyObject *) {
  PSSMShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMShaderGenerator, (void **)&local_this, "PSSMShaderGenerator.start_update")) {
    return nullptr;
  }
  // 1-void PSSMShaderGenerator::start_update(void)
  (*local_this).start_update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_start_update_208_comment =
  "C++ Interface:\n"
  "start_update(const PSSMShaderGenerator self)\n";
#else
static const char *Dtool_PSSMShaderGenerator_start_update_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PSSMShaderGenerator::add_shader(PointerTo< ShaderSpec > spec)
 */
static PyObject *Dtool_PSSMShaderGenerator_add_shader_209(PyObject *self, PyObject *arg) {
  PSSMShaderGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMShaderGenerator, (void **)&local_this, "PSSMShaderGenerator.add_shader")) {
    return nullptr;
  }
  // 1-void PSSMShaderGenerator::add_shader(PointerTo< ShaderSpec > spec)
  PT(ShaderSpec) arg_this;
  if (!Dtool_Coerce_ShaderSpec(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PSSMShaderGenerator.add_shader", "ShaderSpec");
  }
  (*local_this).add_shader(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_shader(const PSSMShaderGenerator self, ShaderSpec spec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_add_shader_209_comment =
  "C++ Interface:\n"
  "add_shader(const PSSMShaderGenerator self, ShaderSpec spec)\n";
#else
static const char *Dtool_PSSMShaderGenerator_add_shader_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PSSMShaderGenerator::has_shadow_sunlight(void) const
 */
static PyObject *Dtool_PSSMShaderGenerator_has_shadow_sunlight_210(PyObject *self, PyObject *) {
  PSSMShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PSSMShaderGenerator)) {
    return nullptr;
  }
  // 1-inline bool PSSMShaderGenerator::has_shadow_sunlight(void) const
  bool return_value = (*(const PSSMShaderGenerator*)local_this).has_shadow_sunlight();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_has_shadow_sunlight_210_comment =
  "C++ Interface:\n"
  "has_shadow_sunlight(PSSMShaderGenerator self)\n";
#else
static const char *Dtool_PSSMShaderGenerator_has_shadow_sunlight_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *PSSMShaderGenerator::get_pssm_array_texture(void) const
 */
static PyObject *Dtool_PSSMShaderGenerator_get_pssm_array_texture_211(PyObject *self, PyObject *) {
  PSSMShaderGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PSSMShaderGenerator)) {
    return nullptr;
  }
  // 1-inline Texture *PSSMShaderGenerator::get_pssm_array_texture(void) const
  Texture *return_value = (*(const PSSMShaderGenerator*)local_this).get_pssm_array_texture();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_get_pssm_array_texture_211_comment =
  "C++ Interface:\n"
  "get_pssm_array_texture(PSSMShaderGenerator self)\n";
#else
static const char *Dtool_PSSMShaderGenerator_get_pssm_array_texture_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Texture *PSSMShaderGenerator::get_identity_cubemap(void)
 */
static PyObject *Dtool_PSSMShaderGenerator_get_identity_cubemap_213(PyObject *, PyObject *) {
  // 1-static Texture *PSSMShaderGenerator::get_identity_cubemap(void)
  Texture *return_value = PSSMShaderGenerator::get_identity_cubemap();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_get_identity_cubemap_213_comment =
  "C++ Interface:\n"
  "get_identity_cubemap()\n";
#else
static const char *Dtool_PSSMShaderGenerator_get_identity_cubemap_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PSSMShaderGenerator::get_class_type(void)
 */
static PyObject *Dtool_PSSMShaderGenerator_get_class_type_214(PyObject *, PyObject *) {
  // 1-static TypeHandle PSSMShaderGenerator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PSSMShaderGenerator::get_class_type());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PSSMShaderGenerator_get_class_type_214_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PSSMShaderGenerator_get_class_type_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PSSMShaderGenerator::PSSMShaderGenerator(GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
 * inline PSSMShaderGenerator::PSSMShaderGenerator(PSSMShaderGenerator const &) = default
 */
static int Dtool_Init_PSSMShaderGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PSSMShaderGenerator::PSSMShaderGenerator(PSSMShaderGenerator const &) = default
      CPT(PSSMShaderGenerator) arg_this;
      if (!Dtool_ConstCoerce_PSSMShaderGenerator(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "PSSMShaderGenerator.PSSMShaderGenerator", "PSSMShaderGenerator");
        return -1;
      }
      PSSMShaderGenerator *return_value = new PSSMShaderGenerator(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSSMShaderGenerator, true, false);
    }
    break;
  case 3:
    {
      // 1-PSSMShaderGenerator::PSSMShaderGenerator(GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"gsg", "camera", "render", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:PSSMShaderGenerator", (char **)keyword_list, &param0, &param1, &param2)) {
        GraphicsStateGuardian *param0_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardian, 0, "PSSMShaderGenerator.PSSMShaderGenerator", false, true);
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "PSSMShaderGenerator.PSSMShaderGenerator", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "PSSMShaderGenerator.PSSMShaderGenerator", true, true);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          PSSMShaderGenerator *return_value = new PSSMShaderGenerator(param0_this, *param1_this, *param2_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSSMShaderGenerator, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PSSMShaderGenerator() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PSSMShaderGenerator(const PSSMShaderGenerator param0)\n"
      "PSSMShaderGenerator(GraphicsStateGuardian gsg, const NodePath camera, const NodePath render)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PSSMShaderGenerator(PyObject *args, CPT(PSSMShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PSSMShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-PSSMShaderGenerator::PSSMShaderGenerator(GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "PSSMShaderGenerator", 3, 3, &param0, &param1, &param2)) {
        GraphicsStateGuardian *param0_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardian, 0, "PSSMShaderGenerator.PSSMShaderGenerator", false, false);
        NodePath const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          PSSMShaderGenerator *return_value = new PSSMShaderGenerator(param0_this, *param1_this, *param2_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PSSMShaderGenerator(PyObject *args, PT(PSSMShaderGenerator) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PSSMShaderGenerator)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-PSSMShaderGenerator::PSSMShaderGenerator(GraphicsStateGuardian *gsg, NodePath const &camera, NodePath const &render)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "PSSMShaderGenerator", 3, 3, &param0, &param1, &param2)) {
        GraphicsStateGuardian *param0_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsStateGuardian, 0, "PSSMShaderGenerator.PSSMShaderGenerator", false, false);
        NodePath const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NodePath);
        NodePath const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          PSSMShaderGenerator *return_value = new PSSMShaderGenerator(param0_this, *param1_this, *param2_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PSSMShaderGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PSSMShaderGenerator) {
    printf("PSSMShaderGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PSSMShaderGenerator *local_this = (PSSMShaderGenerator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PSSMShaderGenerator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderGenerator) {
    return (ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(ShaderGenerator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PSSMShaderGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PSSMShaderGenerator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PSSMShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderGenerator) {
    ShaderGenerator* other_this = (ShaderGenerator*)from_this;
    return (PSSMShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PSSMShaderGenerator*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PSSMShaderGenerator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VertexLitGenericSpec
 */
/**
 * Python function wrapper for:
 * VertexLitGenericSpec::VertexLitGenericSpec(void)
 */
static int Dtool_Init_VertexLitGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("VertexLitGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VertexLitGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-VertexLitGenericSpec::VertexLitGenericSpec(void)
  VertexLitGenericSpec *return_value = new VertexLitGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VertexLitGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VertexLitGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VertexLitGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VertexLitGenericSpec) {
    printf("VertexLitGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VertexLitGenericSpec *local_this = (VertexLitGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VertexLitGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VertexLitGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VertexLitGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (VertexLitGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LightmappedGenericSpec
 */
/**
 * Python function wrapper for:
 * LightmappedGenericSpec::LightmappedGenericSpec(void)
 */
static int Dtool_Init_LightmappedGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LightmappedGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LightmappedGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-LightmappedGenericSpec::LightmappedGenericSpec(void)
  LightmappedGenericSpec *return_value = new LightmappedGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LightmappedGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LightmappedGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LightmappedGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LightmappedGenericSpec) {
    printf("LightmappedGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LightmappedGenericSpec *local_this = (LightmappedGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LightmappedGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LightmappedGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LightmappedGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (LightmappedGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UnlitGenericSpec
 */
/**
 * Python function wrapper for:
 * UnlitGenericSpec::UnlitGenericSpec(void)
 */
static int Dtool_Init_UnlitGenericSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("UnlitGenericSpec() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UnlitGenericSpec() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-UnlitGenericSpec::UnlitGenericSpec(void)
  UnlitGenericSpec *return_value = new UnlitGenericSpec();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnlitGenericSpec, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnlitGenericSpec()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UnlitGenericSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UnlitGenericSpec) {
    printf("UnlitGenericSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UnlitGenericSpec *local_this = (UnlitGenericSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UnlitGenericSpec) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(ShaderSpec *) local_this;
  }
  if (requested_type == Dtool_Ptr_ShaderSpec) {
    return (ShaderSpec *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UnlitGenericSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UnlitGenericSpec) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  if (from_type == Dtool_Ptr_ShaderSpec) {
    ShaderSpec* other_this = (ShaderSpec*)from_this;
    return (UnlitGenericSpec*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for TextureStages (TextureStages)
 */
static PyMethodDef Dtool_Methods_TextureStages[] = {
  {"get", (PyCFunction) &Dtool_TextureStages_get_2, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextureStages_get_2_comment},
  {"get_basetexture", &Dtool_TextureStages_get_basetexture_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_basetexture_3_comment},
  {"getBasetexture", &Dtool_TextureStages_get_basetexture_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_basetexture_3_comment},
  {"get_lightmap", &Dtool_TextureStages_get_lightmap_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_lightmap_4_comment},
  {"getLightmap", &Dtool_TextureStages_get_lightmap_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_lightmap_4_comment},
  {"get_bumped_lightmap", &Dtool_TextureStages_get_bumped_lightmap_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_bumped_lightmap_5_comment},
  {"getBumpedLightmap", &Dtool_TextureStages_get_bumped_lightmap_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_bumped_lightmap_5_comment},
  {"get_spheremap", &Dtool_TextureStages_get_spheremap_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_spheremap_6_comment},
  {"getSpheremap", &Dtool_TextureStages_get_spheremap_6, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_spheremap_6_comment},
  {"get_cubemap", &Dtool_TextureStages_get_cubemap_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_cubemap_7_comment},
  {"getCubemap", &Dtool_TextureStages_get_cubemap_7, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_cubemap_7_comment},
  {"get_normalmap", &Dtool_TextureStages_get_normalmap_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_normalmap_8_comment},
  {"getNormalmap", &Dtool_TextureStages_get_normalmap_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_normalmap_8_comment},
  {"get_heightmap", &Dtool_TextureStages_get_heightmap_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_heightmap_9_comment},
  {"getHeightmap", &Dtool_TextureStages_get_heightmap_9, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_heightmap_9_comment},
  {"get_glossmap", &Dtool_TextureStages_get_glossmap_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glossmap_10_comment},
  {"getGlossmap", &Dtool_TextureStages_get_glossmap_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glossmap_10_comment},
  {"get_glowmap", &Dtool_TextureStages_get_glowmap_11, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glowmap_11_comment},
  {"getGlowmap", &Dtool_TextureStages_get_glowmap_11, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextureStages_get_glowmap_11_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TextureStages = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextureStages = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.TextureStages",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureStages,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureStages,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This simple interface maintains a single TextureStage object for each unique name.\n"
    " * It avoids the creation of duplicate TextureStages with the same name, which\n"
    " * reduces texture swapping and draw call overhead.\n"
    " *\n"
    " * If using our shader system, you should always use this interface to get TextureStages.\n"
    " * You are not required to change any properties on the returned TextureStage, as the shader\n"
    " * specification will know what to do with the TextureStage from the name.\n"
    " * \n"
    " * For example, you do not need to call TextureStage::set_mode() or NodePath::set_tex_gen().\n"
    " * If you apply a texture to a node with the get_normalmap() stage, the shader specification\n"
    " * will know that the texture you supplied is to be treated as a normal map.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureStages,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureStages,
    PyType_GenericAlloc,
    Dtool_new_TextureStages,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureStages,
  Dtool_UpcastInterface_TextureStages,
  Dtool_DowncastInterface_TextureStages,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureStages(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureStages._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureStages._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureStages) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureStages)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureStages);
  }
}

/**
 * Python method tables for BSPMaterial (BSPMaterial)
 */
static PyMethodDef Dtool_Methods_BSPMaterial[] = {
  {"assign", &Dtool_BSPMaterial_operator_17, METH_O, (const char *)Dtool_BSPMaterial_operator_17_comment},
  {"set_keyvalue", (PyCFunction) &Dtool_BSPMaterial_set_keyvalue_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPMaterial_set_keyvalue_18_comment},
  {"setKeyvalue", (PyCFunction) &Dtool_BSPMaterial_set_keyvalue_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPMaterial_set_keyvalue_18_comment},
  {"get_keyvalue", &Dtool_BSPMaterial_get_keyvalue_19, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_19_comment},
  {"getKeyvalue", &Dtool_BSPMaterial_get_keyvalue_19, METH_O, (const char *)Dtool_BSPMaterial_get_keyvalue_19_comment},
  {"set_shader", &Dtool_BSPMaterial_set_shader_20, METH_O, (const char *)Dtool_BSPMaterial_set_shader_20_comment},
  {"setShader", &Dtool_BSPMaterial_set_shader_20, METH_O, (const char *)Dtool_BSPMaterial_set_shader_20_comment},
  {"get_shader", &Dtool_BSPMaterial_get_shader_21, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_shader_21_comment},
  {"getShader", &Dtool_BSPMaterial_get_shader_21, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_shader_21_comment},
  {"get_file", &Dtool_BSPMaterial_get_file_22, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_file_22_comment},
  {"getFile", &Dtool_BSPMaterial_get_file_22, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_file_22_comment},
  {"has_keyvalue", &Dtool_BSPMaterial_has_keyvalue_23, METH_O, (const char *)Dtool_BSPMaterial_has_keyvalue_23_comment},
  {"hasKeyvalue", &Dtool_BSPMaterial_has_keyvalue_23, METH_O, (const char *)Dtool_BSPMaterial_has_keyvalue_23_comment},
  {"has_env_cubemap", &Dtool_BSPMaterial_has_env_cubemap_24, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_env_cubemap_24_comment},
  {"hasEnvCubemap", &Dtool_BSPMaterial_has_env_cubemap_24, METH_NOARGS, (const char *)Dtool_BSPMaterial_has_env_cubemap_24_comment},
  {"get_surface_prop", &Dtool_BSPMaterial_get_surface_prop_25, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_surface_prop_25_comment},
  {"getSurfaceProp", &Dtool_BSPMaterial_get_surface_prop_25, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_surface_prop_25_comment},
  {"get_contents", &Dtool_BSPMaterial_get_contents_26, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_contents_26_comment},
  {"getContents", &Dtool_BSPMaterial_get_contents_26, METH_NOARGS, (const char *)Dtool_BSPMaterial_get_contents_26_comment},
  {"get_from_file", &Dtool_BSPMaterial_get_from_file_27, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterial_get_from_file_27_comment},
  {"getFromFile", &Dtool_BSPMaterial_get_from_file_27, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterial_get_from_file_27_comment},
  {"get_class_type", &Dtool_BSPMaterial_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterial_get_class_type_28_comment},
  {"getClassType", &Dtool_BSPMaterial_get_class_type_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterial_get_class_type_28_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPMaterial = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPMaterial = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPMaterial = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPMaterial",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPMaterial,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPMaterial,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPMaterial,
    &Dtool_SequenceMethods_BSPMaterial,
    &Dtool_MappingMethods_BSPMaterial,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPMaterial,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPMaterial,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPMaterial,
    PyType_GenericAlloc,
    Dtool_new_BSPMaterial,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPMaterial,
  Dtool_UpcastInterface_BSPMaterial,
  Dtool_DowncastInterface_BSPMaterial,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPMaterial(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPMaterial._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_BSPMaterial._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPMaterial) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPMaterial)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPMaterial);
  }
}

/**
 * Python method tables for BSPMaterialAttrib (BSPMaterialAttrib)
 */
static PyMethodDef Dtool_Methods_BSPMaterialAttrib[] = {
  {"make", &Dtool_BSPMaterialAttrib_make_32, METH_O | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_32_comment},
  {"make_default", &Dtool_BSPMaterialAttrib_make_default_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_default_33_comment},
  {"makeDefault", &Dtool_BSPMaterialAttrib_make_default_33, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_make_default_33_comment},
  {"get_material", &Dtool_BSPMaterialAttrib_get_material_34, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_material_34_comment},
  {"getMaterial", &Dtool_BSPMaterialAttrib_get_material_34, METH_NOARGS, (const char *)Dtool_BSPMaterialAttrib_get_material_34_comment},
  {"get_class_slot", &Dtool_BSPMaterialAttrib_get_class_slot_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_slot_35_comment},
  {"getClassSlot", &Dtool_BSPMaterialAttrib_get_class_slot_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_slot_35_comment},
  {"get_class_type", &Dtool_BSPMaterialAttrib_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_type_38_comment},
  {"getClassType", &Dtool_BSPMaterialAttrib_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPMaterialAttrib_get_class_type_38_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPMaterialAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPMaterialAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPMaterialAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPMaterialAttrib",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPMaterialAttrib,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPMaterialAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPMaterialAttrib,
    &Dtool_SequenceMethods_BSPMaterialAttrib,
    &Dtool_MappingMethods_BSPMaterialAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPMaterialAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPMaterialAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPMaterialAttrib,
    PyType_GenericAlloc,
    Dtool_new_BSPMaterialAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPMaterialAttrib,
  Dtool_UpcastInterface_BSPMaterialAttrib,
  Dtool_DowncastInterface_BSPMaterialAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BSPMaterialAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPMaterialAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPMaterialAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    PyObject *dict = PyDict_New();
    Dtool_BSPMaterialAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BSPMaterialAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BSPMaterialAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPMaterialAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPMaterialAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPMaterialAttrib);
  }
}

/**
 * Python method tables for CBaseEntity (CBaseEntity)
 */
static PyMethodDef Dtool_Methods_CBaseEntity[] = {
  {"get_class_type", &Dtool_CBaseEntity_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_41_comment},
  {"getClassType", &Dtool_CBaseEntity_get_class_type_41, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBaseEntity_get_class_type_41_comment},
  {"get_entnum", &Dtool_CBaseEntity_get_entnum_43, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_entnum_43_comment},
  {"getEntnum", &Dtool_CBaseEntity_get_entnum_43, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_entnum_43_comment},
  {"get_loader", &Dtool_CBaseEntity_get_loader_44, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_44_comment},
  {"getLoader", &Dtool_CBaseEntity_get_loader_44, METH_NOARGS, (const char *)Dtool_CBaseEntity_get_loader_44_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBaseEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBaseEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBaseEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBaseEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBaseEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBaseEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBaseEntity,
    &Dtool_SequenceMethods_CBaseEntity,
    &Dtool_MappingMethods_CBaseEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBaseEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBaseEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBaseEntity,
    PyType_GenericAlloc,
    Dtool_new_CBaseEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBaseEntity,
  Dtool_UpcastInterface_CBaseEntity,
  Dtool_DowncastInterface_CBaseEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBaseEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CBaseEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_CBaseEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBaseEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBaseEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBaseEntity);
  }
}

/**
 * Python method tables for CPointEntity (CPointEntity)
 */
static PyMethodDef Dtool_Methods_CPointEntity[] = {
  {"get_class_type", &Dtool_CPointEntity_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_47_comment},
  {"getClassType", &Dtool_CPointEntity_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_CPointEntity_get_class_type_47_comment},
  {"get_origin", &Dtool_CPointEntity_get_origin_49, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_49_comment},
  {"getOrigin", &Dtool_CPointEntity_get_origin_49, METH_NOARGS, (const char *)Dtool_CPointEntity_get_origin_49_comment},
  {"get_angles", &Dtool_CPointEntity_get_angles_50, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_50_comment},
  {"getAngles", &Dtool_CPointEntity_get_angles_50, METH_NOARGS, (const char *)Dtool_CPointEntity_get_angles_50_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CPointEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CPointEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CPointEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CPointEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CPointEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CPointEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CPointEntity,
    &Dtool_SequenceMethods_CPointEntity,
    &Dtool_MappingMethods_CPointEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CPointEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CPointEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CPointEntity,
    PyType_GenericAlloc,
    Dtool_new_CPointEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CPointEntity,
  Dtool_UpcastInterface_CPointEntity,
  Dtool_DowncastInterface_CPointEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CPointEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CPointEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CPointEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CPointEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CPointEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CPointEntity);
  }
}

/**
 * Python method tables for CBoundsEntity (CBoundsEntity)
 */
static PyMethodDef Dtool_Methods_CBoundsEntity[] = {
  {"get_class_type", &Dtool_CBoundsEntity_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_53_comment},
  {"getClassType", &Dtool_CBoundsEntity_get_class_type_53, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBoundsEntity_get_class_type_53_comment},
  {"get_bounds", &Dtool_CBoundsEntity_get_bounds_55, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_55_comment},
  {"getBounds", &Dtool_CBoundsEntity_get_bounds_55, METH_NOARGS, (const char *)Dtool_CBoundsEntity_get_bounds_55_comment},
  {"is_inside", &Dtool_CBoundsEntity_is_inside_56, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_56_comment},
  {"isInside", &Dtool_CBoundsEntity_is_inside_56, METH_O, (const char *)Dtool_CBoundsEntity_is_inside_56_comment},
  {"fillin_bounds", (PyCFunction) &Dtool_CBoundsEntity_fillin_bounds_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBoundsEntity_fillin_bounds_57_comment},
  {"fillinBounds", (PyCFunction) &Dtool_CBoundsEntity_fillin_bounds_57, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBoundsEntity_fillin_bounds_57_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBoundsEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBoundsEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBoundsEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBoundsEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBoundsEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBoundsEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBoundsEntity,
    &Dtool_SequenceMethods_CBoundsEntity,
    &Dtool_MappingMethods_CBoundsEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBoundsEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A flavor of a brush entity (but doesn't inherit from CBrushEntity) which uses the brush only to describe\n"
    " * the bounds. Useful for triggers or water, because we don't actually care about the brush's geometry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBoundsEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBoundsEntity,
    PyType_GenericAlloc,
    Dtool_new_CBoundsEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBoundsEntity,
  Dtool_UpcastInterface_CBoundsEntity,
  Dtool_DowncastInterface_CBoundsEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBoundsEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBoundsEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CBoundsEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBoundsEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBoundsEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBoundsEntity);
  }
}

/**
 * Python method tables for CBrushEntity (CBrushEntity)
 */
static PyMethodDef Dtool_Methods_CBrushEntity[] = {
  {"get_class_type", &Dtool_CBrushEntity_get_class_type_60, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_60_comment},
  {"getClassType", &Dtool_CBrushEntity_get_class_type_60, METH_NOARGS | METH_STATIC, (const char *)Dtool_CBrushEntity_get_class_type_60_comment},
  {"get_modelnum", &Dtool_CBrushEntity_get_modelnum_62, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_modelnum_62_comment},
  {"getModelnum", &Dtool_CBrushEntity_get_modelnum_62, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_modelnum_62_comment},
  {"get_model_np", &Dtool_CBrushEntity_get_model_np_63, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_63_comment},
  {"getModelNp", &Dtool_CBrushEntity_get_model_np_63, METH_NOARGS, (const char *)Dtool_CBrushEntity_get_model_np_63_comment},
  {"get_model_bounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_64_comment},
  {"getModelBounds", (PyCFunction) &Dtool_CBrushEntity_get_model_bounds_64, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CBrushEntity_get_model_bounds_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CBrushEntity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CBrushEntity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CBrushEntity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.CBrushEntity",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CBrushEntity,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CBrushEntity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CBrushEntity,
    &Dtool_SequenceMethods_CBrushEntity,
    &Dtool_MappingMethods_CBrushEntity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CBrushEntity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CBrushEntity,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CBrushEntity,
    PyType_GenericAlloc,
    Dtool_new_CBrushEntity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CBrushEntity,
  Dtool_UpcastInterface_CBrushEntity,
  Dtool_DowncastInterface_CBrushEntity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CBrushEntity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CBaseEntity(nullptr);
    Dtool_CBrushEntity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CBaseEntity);
    PyObject *dict = PyDict_New();
    Dtool_CBrushEntity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CBrushEntity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CBrushEntity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CBrushEntity);
  }
}

/**
 * Python method tables for PackResult (PackResult)
 */
static PyMethodDef Dtool_Methods_PackResult[] = {
  {"get_width", &Dtool_PackResult_get_width_67, METH_NOARGS, (const char *)Dtool_PackResult_get_width_67_comment},
  {"getWidth", &Dtool_PackResult_get_width_67, METH_NOARGS, (const char *)Dtool_PackResult_get_width_67_comment},
  {"get_height", &Dtool_PackResult_get_height_68, METH_NOARGS, (const char *)Dtool_PackResult_get_height_68_comment},
  {"getHeight", &Dtool_PackResult_get_height_68, METH_NOARGS, (const char *)Dtool_PackResult_get_height_68_comment},
  {"get_unused_area", &Dtool_PackResult_get_unused_area_69, METH_NOARGS, (const char *)Dtool_PackResult_get_unused_area_69_comment},
  {"getUnusedArea", &Dtool_PackResult_get_unused_area_69, METH_NOARGS, (const char *)Dtool_PackResult_get_unused_area_69_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PackResult = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PackResult = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.PackResult",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PackResult,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PackResult,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PackResult,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PackResult,
    PyType_GenericAlloc,
    Dtool_new_PackResult,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PackResult,
  Dtool_UpcastInterface_PackResult,
  Dtool_DowncastInterface_PackResult,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PackResult(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PackResult._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PackResult._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PackResult) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PackResult)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PackResult);
  }
}

/**
 * Python method tables for TextureLocation (TextureLocation)
 */
static PyMethodDef Dtool_Methods_TextureLocation[] = {
  {"get_x", &Dtool_TextureLocation_get_x_73, METH_NOARGS, (const char *)Dtool_TextureLocation_get_x_73_comment},
  {"getX", &Dtool_TextureLocation_get_x_73, METH_NOARGS, (const char *)Dtool_TextureLocation_get_x_73_comment},
  {"get_y", &Dtool_TextureLocation_get_y_74, METH_NOARGS, (const char *)Dtool_TextureLocation_get_y_74_comment},
  {"getY", &Dtool_TextureLocation_get_y_74, METH_NOARGS, (const char *)Dtool_TextureLocation_get_y_74_comment},
  {"get_width", &Dtool_TextureLocation_get_width_75, METH_NOARGS, (const char *)Dtool_TextureLocation_get_width_75_comment},
  {"getWidth", &Dtool_TextureLocation_get_width_75, METH_NOARGS, (const char *)Dtool_TextureLocation_get_width_75_comment},
  {"get_height", &Dtool_TextureLocation_get_height_76, METH_NOARGS, (const char *)Dtool_TextureLocation_get_height_76_comment},
  {"getHeight", &Dtool_TextureLocation_get_height_76, METH_NOARGS, (const char *)Dtool_TextureLocation_get_height_76_comment},
  {"get_rotated", &Dtool_TextureLocation_get_rotated_77, METH_NOARGS, (const char *)Dtool_TextureLocation_get_rotated_77_comment},
  {"getRotated", &Dtool_TextureLocation_get_rotated_77, METH_NOARGS, (const char *)Dtool_TextureLocation_get_rotated_77_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TextureLocation = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TextureLocation = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.TextureLocation",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextureLocation,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TextureLocation,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TextureLocation,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TextureLocation,
    PyType_GenericAlloc,
    Dtool_new_TextureLocation,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextureLocation,
  Dtool_UpcastInterface_TextureLocation,
  Dtool_DowncastInterface_TextureLocation,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TextureLocation(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextureLocation._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TextureLocation._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TextureLocation) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextureLocation)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextureLocation);
  }
}

/**
 * Python method tables for TexturePacker (TexturePacker)
 */
static PyMethodDef Dtool_Methods_TexturePacker[] = {
  {"getTextureCount", &Dtool_TexturePacker_getTextureCount_81, METH_NOARGS, (const char *)Dtool_TexturePacker_getTextureCount_81_comment},
  {"setTextureCount", &Dtool_TexturePacker_setTextureCount_82, METH_O, (const char *)Dtool_TexturePacker_setTextureCount_82_comment},
  {"addTexture", (PyCFunction) &Dtool_TexturePacker_addTexture_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_addTexture_83_comment},
  {"wouldTextureFit", (PyCFunction) &Dtool_TexturePacker_wouldTextureFit_84, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_wouldTextureFit_84_comment},
  {"addNewTexture", (PyCFunction) &Dtool_TexturePacker_addNewTexture_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_addNewTexture_85_comment},
  {"packTextures", (PyCFunction) &Dtool_TexturePacker_packTextures_86, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TexturePacker_packTextures_86_comment},
  {"getTextureLocation", &Dtool_TexturePacker_getTextureLocation_87, METH_O, (const char *)Dtool_TexturePacker_getTextureLocation_87_comment},
  {"createTexturePacker", &Dtool_TexturePacker_createTexturePacker_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_TexturePacker_createTexturePacker_88_comment},
  {"releaseTexturePacker", &Dtool_TexturePacker_releaseTexturePacker_89, METH_O | METH_STATIC, (const char *)Dtool_TexturePacker_releaseTexturePacker_89_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TexturePacker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TexturePacker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.TexturePacker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TexturePacker,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TexturePacker,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TexturePacker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TexturePacker,
    PyType_GenericAlloc,
    Dtool_new_TexturePacker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TexturePacker,
  Dtool_UpcastInterface_TexturePacker,
  Dtool_DowncastInterface_TexturePacker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TexturePacker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TexturePacker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TexturePacker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TexturePacker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TexturePacker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TexturePacker);
  }
}

/**
 * Python method tables for BSPFaceAttrib (BSPFaceAttrib)
 */
static PyMethodDef Dtool_Methods_BSPFaceAttrib[] = {
  {"make", (PyCFunction) &Dtool_BSPFaceAttrib_make_93, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_93_comment},
  {"make_default", &Dtool_BSPFaceAttrib_make_default_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_94_comment},
  {"makeDefault", &Dtool_BSPFaceAttrib_make_default_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_default_94_comment},
  {"make_ignore_pvs", &Dtool_BSPFaceAttrib_make_ignore_pvs_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_ignore_pvs_95_comment},
  {"makeIgnorePvs", &Dtool_BSPFaceAttrib_make_ignore_pvs_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_make_ignore_pvs_95_comment},
  {"get_material", &Dtool_BSPFaceAttrib_get_material_96, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_96_comment},
  {"getMaterial", &Dtool_BSPFaceAttrib_get_material_96, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_material_96_comment},
  {"get_face_type", &Dtool_BSPFaceAttrib_get_face_type_97, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_face_type_97_comment},
  {"getFaceType", &Dtool_BSPFaceAttrib_get_face_type_97, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_face_type_97_comment},
  {"get_ignore_pvs", &Dtool_BSPFaceAttrib_get_ignore_pvs_98, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_ignore_pvs_98_comment},
  {"getIgnorePvs", &Dtool_BSPFaceAttrib_get_ignore_pvs_98, METH_NOARGS, (const char *)Dtool_BSPFaceAttrib_get_ignore_pvs_98_comment},
  {"get_class_slot", &Dtool_BSPFaceAttrib_get_class_slot_99, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_99_comment},
  {"getClassSlot", &Dtool_BSPFaceAttrib_get_class_slot_99, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_slot_99_comment},
  {"get_class_type", &Dtool_BSPFaceAttrib_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_101_comment},
  {"getClassType", &Dtool_BSPFaceAttrib_get_class_type_101, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPFaceAttrib_get_class_type_101_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPFaceAttrib = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPFaceAttrib = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPFaceAttrib = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPFaceAttrib",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPFaceAttrib,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPFaceAttrib,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPFaceAttrib,
    &Dtool_SequenceMethods_BSPFaceAttrib,
    &Dtool_MappingMethods_BSPFaceAttrib,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPFaceAttrib,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An attribute applied to each face Geom from a BSP file.\n"
    " * All it does right now is indicate the material of the face\n"
    " * and if it's a wall or a floor (depending on the face normal).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPFaceAttrib,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPFaceAttrib,
    PyType_GenericAlloc,
    Dtool_new_BSPFaceAttrib,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPFaceAttrib,
  Dtool_UpcastInterface_BSPFaceAttrib,
  Dtool_DowncastInterface_BSPFaceAttrib,
  (CoerceFunction)Dtool_ConstCoerce_BSPFaceAttrib,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPFaceAttrib(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_RenderAttrib != nullptr);
    assert(Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_RenderAttrib->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPFaceAttrib._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_RenderAttrib);
    PyObject *dict = PyDict_New();
    Dtool_BSPFaceAttrib._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPFaceAttrib::;
    PyDict_SetItemString(dict, "FACETYPE_WALL", Dtool_WrapValue(BSPFaceAttrib::FACETYPE_WALL));
    PyDict_SetItemString(dict, "FACETYPE_FLOOR", Dtool_WrapValue(BSPFaceAttrib::FACETYPE_FLOOR));
    static const PyGetSetDef def_class_slot = {(char *)"class_slot", &Dtool_BSPFaceAttrib_class_slot_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "class_slot", Dtool_NewStaticProperty(&Dtool_BSPFaceAttrib._PyType, &def_class_slot));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPFaceAttrib) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPFaceAttrib)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPFaceAttrib);
  }
}

/**
 * Python method tables for BSPLoader (BSPLoader)
 */
static PyMethodDef Dtool_Methods_BSPLoader[] = {
  {"read", &Dtool_BSPLoader_read_105, METH_O, (const char *)Dtool_BSPLoader_read_105_comment},
  {"do_optimizations", &Dtool_BSPLoader_do_optimizations_106, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_106_comment},
  {"doOptimizations", &Dtool_BSPLoader_do_optimizations_106, METH_NOARGS, (const char *)Dtool_BSPLoader_do_optimizations_106_comment},
  {"set_gamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_107_comment},
  {"setGamma", (PyCFunction) &Dtool_BSPLoader_set_gamma_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_gamma_107_comment},
  {"get_gamma", &Dtool_BSPLoader_get_gamma_108, METH_NOARGS, (const char *)Dtool_BSPLoader_get_gamma_108_comment},
  {"getGamma", &Dtool_BSPLoader_get_gamma_108, METH_NOARGS, (const char *)Dtool_BSPLoader_get_gamma_108_comment},
  {"set_win", &Dtool_BSPLoader_set_win_109, METH_O, (const char *)Dtool_BSPLoader_set_win_109_comment},
  {"setWin", &Dtool_BSPLoader_set_win_109, METH_O, (const char *)Dtool_BSPLoader_set_win_109_comment},
  {"set_camera", &Dtool_BSPLoader_set_camera_110, METH_O, (const char *)Dtool_BSPLoader_set_camera_110_comment},
  {"setCamera", &Dtool_BSPLoader_set_camera_110, METH_O, (const char *)Dtool_BSPLoader_set_camera_110_comment},
  {"set_render", &Dtool_BSPLoader_set_render_111, METH_O, (const char *)Dtool_BSPLoader_set_render_111_comment},
  {"setRender", &Dtool_BSPLoader_set_render_111, METH_O, (const char *)Dtool_BSPLoader_set_render_111_comment},
  {"set_want_visibility", &Dtool_BSPLoader_set_want_visibility_112, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_112_comment},
  {"setWantVisibility", &Dtool_BSPLoader_set_want_visibility_112, METH_O, (const char *)Dtool_BSPLoader_set_want_visibility_112_comment},
  {"set_want_lightmaps", &Dtool_BSPLoader_set_want_lightmaps_113, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_113_comment},
  {"setWantLightmaps", &Dtool_BSPLoader_set_want_lightmaps_113, METH_O, (const char *)Dtool_BSPLoader_set_want_lightmaps_113_comment},
  {"set_physics_type", &Dtool_BSPLoader_set_physics_type_114, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_114_comment},
  {"setPhysicsType", &Dtool_BSPLoader_set_physics_type_114, METH_O, (const char *)Dtool_BSPLoader_set_physics_type_114_comment},
  {"set_visualize_leafs", &Dtool_BSPLoader_set_visualize_leafs_115, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_115_comment},
  {"setVisualizeLeafs", &Dtool_BSPLoader_set_visualize_leafs_115, METH_O, (const char *)Dtool_BSPLoader_set_visualize_leafs_115_comment},
  {"set_materials_file", &Dtool_BSPLoader_set_materials_file_116, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_116_comment},
  {"setMaterialsFile", &Dtool_BSPLoader_set_materials_file_116, METH_O, (const char *)Dtool_BSPLoader_set_materials_file_116_comment},
  {"set_wireframe", &Dtool_BSPLoader_set_wireframe_117, METH_O, (const char *)Dtool_BSPLoader_set_wireframe_117_comment},
  {"setWireframe", &Dtool_BSPLoader_set_wireframe_117, METH_O, (const char *)Dtool_BSPLoader_set_wireframe_117_comment},
  {"get_wireframe", &Dtool_BSPLoader_get_wireframe_118, METH_NOARGS, (const char *)Dtool_BSPLoader_get_wireframe_118_comment},
  {"getWireframe", &Dtool_BSPLoader_get_wireframe_118, METH_NOARGS, (const char *)Dtool_BSPLoader_get_wireframe_118_comment},
  {"get_camera", &Dtool_BSPLoader_get_camera_119, METH_NOARGS, (const char *)Dtool_BSPLoader_get_camera_119_comment},
  {"getCamera", &Dtool_BSPLoader_get_camera_119, METH_NOARGS, (const char *)Dtool_BSPLoader_get_camera_119_comment},
  {"build_cubemaps", &Dtool_BSPLoader_build_cubemaps_120, METH_NOARGS, (const char *)Dtool_BSPLoader_build_cubemaps_120_comment},
  {"buildCubemaps", &Dtool_BSPLoader_build_cubemaps_120, METH_NOARGS, (const char *)Dtool_BSPLoader_build_cubemaps_120_comment},
  {"setup_shadowcam", &Dtool_BSPLoader_setup_shadowcam_121, METH_NOARGS, (const char *)Dtool_BSPLoader_setup_shadowcam_121_comment},
  {"setupShadowcam", &Dtool_BSPLoader_setup_shadowcam_121, METH_NOARGS, (const char *)Dtool_BSPLoader_setup_shadowcam_121_comment},
  {"add_dynamic_node", &Dtool_BSPLoader_add_dynamic_node_122, METH_O, (const char *)Dtool_BSPLoader_add_dynamic_node_122_comment},
  {"addDynamicNode", &Dtool_BSPLoader_add_dynamic_node_122, METH_O, (const char *)Dtool_BSPLoader_add_dynamic_node_122_comment},
  {"set_want_shadows", &Dtool_BSPLoader_set_want_shadows_123, METH_O, (const char *)Dtool_BSPLoader_set_want_shadows_123_comment},
  {"setWantShadows", &Dtool_BSPLoader_set_want_shadows_123, METH_O, (const char *)Dtool_BSPLoader_set_want_shadows_123_comment},
  {"set_shadow_cam_pos", &Dtool_BSPLoader_set_shadow_cam_pos_124, METH_O, (const char *)Dtool_BSPLoader_set_shadow_cam_pos_124_comment},
  {"setShadowCamPos", &Dtool_BSPLoader_set_shadow_cam_pos_124, METH_O, (const char *)Dtool_BSPLoader_set_shadow_cam_pos_124_comment},
  {"set_shadow_cam_bitmask", &Dtool_BSPLoader_set_shadow_cam_bitmask_125, METH_O, (const char *)Dtool_BSPLoader_set_shadow_cam_bitmask_125_comment},
  {"setShadowCamBitmask", &Dtool_BSPLoader_set_shadow_cam_bitmask_125, METH_O, (const char *)Dtool_BSPLoader_set_shadow_cam_bitmask_125_comment},
  {"set_shadow_color", &Dtool_BSPLoader_set_shadow_color_126, METH_O, (const char *)Dtool_BSPLoader_set_shadow_color_126_comment},
  {"setShadowColor", &Dtool_BSPLoader_set_shadow_color_126, METH_O, (const char *)Dtool_BSPLoader_set_shadow_color_126_comment},
  {"set_shadow_resolution", (PyCFunction) &Dtool_BSPLoader_set_shadow_resolution_127, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_shadow_resolution_127_comment},
  {"setShadowResolution", (PyCFunction) &Dtool_BSPLoader_set_shadow_resolution_127, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_set_shadow_resolution_127_comment},
  {"cast_shadows", &Dtool_BSPLoader_cast_shadows_128, METH_O, (const char *)Dtool_BSPLoader_cast_shadows_128_comment},
  {"castShadows", &Dtool_BSPLoader_cast_shadows_128, METH_O, (const char *)Dtool_BSPLoader_cast_shadows_128_comment},
  {"get_shadow_tex", &Dtool_BSPLoader_get_shadow_tex_129, METH_NOARGS, (const char *)Dtool_BSPLoader_get_shadow_tex_129_comment},
  {"getShadowTex", &Dtool_BSPLoader_get_shadow_tex_129, METH_NOARGS, (const char *)Dtool_BSPLoader_get_shadow_tex_129_comment},
  {"extract_modelnum", &Dtool_BSPLoader_extract_modelnum_130, METH_O, (const char *)Dtool_BSPLoader_extract_modelnum_130_comment},
  {"extractModelnum", &Dtool_BSPLoader_extract_modelnum_130, METH_O, (const char *)Dtool_BSPLoader_extract_modelnum_130_comment},
  {"get_model_bounds", (PyCFunction) &Dtool_BSPLoader_get_model_bounds_131, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_model_bounds_131_comment},
  {"getModelBounds", (PyCFunction) &Dtool_BSPLoader_get_model_bounds_131, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_model_bounds_131_comment},
  {"set_server_entity_dispatcher", &Dtool_BSPLoader_set_server_entity_dispatcher_132, METH_O, (const char *)Dtool_BSPLoader_set_server_entity_dispatcher_132_comment},
  {"setServerEntityDispatcher", &Dtool_BSPLoader_set_server_entity_dispatcher_132, METH_O, (const char *)Dtool_BSPLoader_set_server_entity_dispatcher_132_comment},
  {"link_server_entity_to_class", (PyCFunction) &Dtool_BSPLoader_link_server_entity_to_class_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_server_entity_to_class_133_comment},
  {"linkServerEntityToClass", (PyCFunction) &Dtool_BSPLoader_link_server_entity_to_class_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_server_entity_to_class_133_comment},
  {"set_ai", &Dtool_BSPLoader_set_ai_134, METH_O, (const char *)Dtool_BSPLoader_set_ai_134_comment},
  {"setAi", &Dtool_BSPLoader_set_ai_134, METH_O, (const char *)Dtool_BSPLoader_set_ai_134_comment},
  {"is_ai", &Dtool_BSPLoader_is_ai_135, METH_NOARGS, (const char *)Dtool_BSPLoader_is_ai_135_comment},
  {"isAi", &Dtool_BSPLoader_is_ai_135, METH_NOARGS, (const char *)Dtool_BSPLoader_is_ai_135_comment},
  {"update_dynamic_node", &Dtool_BSPLoader_update_dynamic_node_136, METH_O, (const char *)Dtool_BSPLoader_update_dynamic_node_136_comment},
  {"updateDynamicNode", &Dtool_BSPLoader_update_dynamic_node_136, METH_O, (const char *)Dtool_BSPLoader_update_dynamic_node_136_comment},
  {"trace_line", (PyCFunction) &Dtool_BSPLoader_trace_line_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_line_137_comment},
  {"traceLine", (PyCFunction) &Dtool_BSPLoader_trace_line_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_trace_line_137_comment},
  {"link_entity_to_class", (PyCFunction) &Dtool_BSPLoader_link_entity_to_class_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_entity_to_class_138_comment},
  {"linkEntityToClass", (PyCFunction) &Dtool_BSPLoader_link_entity_to_class_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_entity_to_class_138_comment},
  {"get_py_entity_by_target_name", &Dtool_BSPLoader_get_py_entity_by_target_name_139, METH_O, (const char *)Dtool_BSPLoader_get_py_entity_by_target_name_139_comment},
  {"getPyEntityByTargetName", &Dtool_BSPLoader_get_py_entity_by_target_name_139, METH_O, (const char *)Dtool_BSPLoader_get_py_entity_by_target_name_139_comment},
  {"find_all_entities", &Dtool_BSPLoader_find_all_entities_140, METH_O, (const char *)Dtool_BSPLoader_find_all_entities_140_comment},
  {"findAllEntities", &Dtool_BSPLoader_find_all_entities_140, METH_O, (const char *)Dtool_BSPLoader_find_all_entities_140_comment},
  {"get_entity_keyvalues", (PyCFunction) &Dtool_BSPLoader_get_entity_keyvalues_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_keyvalues_141_comment},
  {"getEntityKeyvalues", (PyCFunction) &Dtool_BSPLoader_get_entity_keyvalues_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_keyvalues_141_comment},
  {"link_cent_to_pyent", (PyCFunction) &Dtool_BSPLoader_link_cent_to_pyent_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_cent_to_pyent_142_comment},
  {"linkCentToPyent", (PyCFunction) &Dtool_BSPLoader_link_cent_to_pyent_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_link_cent_to_pyent_142_comment},
  {"get_num_entities", &Dtool_BSPLoader_get_num_entities_143, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_143_comment},
  {"getNumEntities", &Dtool_BSPLoader_get_num_entities_143, METH_NOARGS, (const char *)Dtool_BSPLoader_get_num_entities_143_comment},
  {"get_entity_value", (PyCFunction) &Dtool_BSPLoader_get_entity_value_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_144_comment},
  {"getEntityValue", (PyCFunction) &Dtool_BSPLoader_get_entity_value_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_144_comment},
  {"get_entity_value_float", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_145_comment},
  {"getEntityValueFloat", (PyCFunction) &Dtool_BSPLoader_get_entity_value_float_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_float_145_comment},
  {"get_entity_value_int", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_146_comment},
  {"getEntityValueInt", (PyCFunction) &Dtool_BSPLoader_get_entity_value_int_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_int_146_comment},
  {"get_entity_value_vector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_147_comment},
  {"getEntityValueVector", (PyCFunction) &Dtool_BSPLoader_get_entity_value_vector_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_vector_147_comment},
  {"get_entity_value_color", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_148_comment},
  {"getEntityValueColor", (PyCFunction) &Dtool_BSPLoader_get_entity_value_color_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_get_entity_value_color_148_comment},
  {"get_entity", &Dtool_BSPLoader_get_entity_149, METH_O, (const char *)Dtool_BSPLoader_get_entity_149_comment},
  {"getEntity", &Dtool_BSPLoader_get_entity_149, METH_O, (const char *)Dtool_BSPLoader_get_entity_149_comment},
  {"get_model", &Dtool_BSPLoader_get_model_150, METH_O, (const char *)Dtool_BSPLoader_get_model_150_comment},
  {"getModel", &Dtool_BSPLoader_get_model_150, METH_O, (const char *)Dtool_BSPLoader_get_model_150_comment},
  {"get_c_entity", &Dtool_BSPLoader_get_c_entity_151, METH_O, (const char *)Dtool_BSPLoader_get_c_entity_151_comment},
  {"getCEntity", &Dtool_BSPLoader_get_c_entity_151, METH_O, (const char *)Dtool_BSPLoader_get_c_entity_151_comment},
  {"find_leaf", &Dtool_BSPLoader_find_leaf_152, METH_O, (const char *)Dtool_BSPLoader_find_leaf_152_comment},
  {"findLeaf", &Dtool_BSPLoader_find_leaf_152, METH_O, (const char *)Dtool_BSPLoader_find_leaf_152_comment},
  {"find_node", &Dtool_BSPLoader_find_node_153, METH_O, (const char *)Dtool_BSPLoader_find_node_153_comment},
  {"findNode", &Dtool_BSPLoader_find_node_153, METH_O, (const char *)Dtool_BSPLoader_find_node_153_comment},
  {"is_cluster_visible", (PyCFunction) &Dtool_BSPLoader_is_cluster_visible_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_is_cluster_visible_154_comment},
  {"isClusterVisible", (PyCFunction) &Dtool_BSPLoader_is_cluster_visible_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_is_cluster_visible_154_comment},
  {"pvs_bounds_test", &Dtool_BSPLoader_pvs_bounds_test_155, METH_O, (const char *)Dtool_BSPLoader_pvs_bounds_test_155_comment},
  {"pvsBoundsTest", &Dtool_BSPLoader_pvs_bounds_test_155, METH_O, (const char *)Dtool_BSPLoader_pvs_bounds_test_155_comment},
  {"make_net_bounds", (PyCFunction) &Dtool_BSPLoader_make_net_bounds_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_make_net_bounds_156_comment},
  {"makeNetBounds", (PyCFunction) &Dtool_BSPLoader_make_net_bounds_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BSPLoader_make_net_bounds_156_comment},
  {"has_active_level", &Dtool_BSPLoader_has_active_level_157, METH_NOARGS, (const char *)Dtool_BSPLoader_has_active_level_157_comment},
  {"hasActiveLevel", &Dtool_BSPLoader_has_active_level_157, METH_NOARGS, (const char *)Dtool_BSPLoader_has_active_level_157_comment},
  {"has_visibility", &Dtool_BSPLoader_has_visibility_158, METH_NOARGS, (const char *)Dtool_BSPLoader_has_visibility_158_comment},
  {"hasVisibility", &Dtool_BSPLoader_has_visibility_158, METH_NOARGS, (const char *)Dtool_BSPLoader_has_visibility_158_comment},
  {"cleanup", &Dtool_BSPLoader_cleanup_159, METH_NOARGS, (const char *)Dtool_BSPLoader_cleanup_159_comment},
  {"get_result", &Dtool_BSPLoader_get_result_160, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_160_comment},
  {"getResult", &Dtool_BSPLoader_get_result_160, METH_NOARGS, (const char *)Dtool_BSPLoader_get_result_160_comment},
  {"get_global_ptr", &Dtool_BSPLoader_get_global_ptr_161, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_161_comment},
  {"getGlobalPtr", &Dtool_BSPLoader_get_global_ptr_161, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPLoader_get_global_ptr_161_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPLoader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BSPLoader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPLoader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPLoader,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPLoader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Loads and handles the operations of PBSP files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPLoader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPLoader,
    PyType_GenericAlloc,
    Dtool_new_BSPLoader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPLoader,
  Dtool_UpcastInterface_BSPLoader,
  Dtool_DowncastInterface_BSPLoader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BSPLoader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BSPLoader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_BSPLoader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BSPLoader::PhysicsType;
    PyDict_SetItemString(dict, "PT_none", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PTNone", Dtool_WrapValue(BSPLoader::PT_none));
    PyDict_SetItemString(dict, "PT_panda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PTPanda", Dtool_WrapValue(BSPLoader::PT_panda));
    PyDict_SetItemString(dict, "PT_bullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PTBullet", Dtool_WrapValue(BSPLoader::PT_bullet));
    PyDict_SetItemString(dict, "PT_ode", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PTOde", Dtool_WrapValue(BSPLoader::PT_ode));
    PyDict_SetItemString(dict, "PT_physx", Dtool_WrapValue(BSPLoader::PT_physx));
    PyDict_SetItemString(dict, "PTPhysx", Dtool_WrapValue(BSPLoader::PT_physx));
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPLoader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPLoader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPLoader);
  }
}

/**
 * Python method tables for BSPCullTraverser (BSPCullTraverser)
 */
static PyMethodDef Dtool_Methods_BSPCullTraverser[] = {
  {"get_class_type", &Dtool_BSPCullTraverser_get_class_type_166, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPCullTraverser_get_class_type_166_comment},
  {"getClassType", &Dtool_BSPCullTraverser_get_class_type_166, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPCullTraverser_get_class_type_166_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPCullTraverser = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPCullTraverser = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPCullTraverser = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPCullTraverser",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPCullTraverser,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPCullTraverser,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPCullTraverser,
    &Dtool_SequenceMethods_BSPCullTraverser,
    &Dtool_MappingMethods_BSPCullTraverser,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPCullTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPCullTraverser,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPCullTraverser,
    PyType_GenericAlloc,
    Dtool_new_BSPCullTraverser,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPCullTraverser,
  Dtool_UpcastInterface_BSPCullTraverser,
  Dtool_DowncastInterface_BSPCullTraverser,
  (CoerceFunction)Dtool_ConstCoerce_BSPCullTraverser,
  (CoerceFunction)Dtool_Coerce_BSPCullTraverser,
};

static void Dtool_PyModuleClassInit_BSPCullTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CullTraverser != nullptr);
    assert(Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CullTraverser->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPCullTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CullTraverser);
    PyObject *dict = PyDict_New();
    Dtool_BSPCullTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPCullTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPCullTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPCullTraverser);
  }
}

/**
 * Python method tables for BSPRender (BSPRender)
 */
static PyMethodDef Dtool_Methods_BSPRender[] = {
  {"get_class_type", &Dtool_BSPRender_get_class_type_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRender_get_class_type_171_comment},
  {"getClassType", &Dtool_BSPRender_get_class_type_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRender_get_class_type_171_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPRender = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPRender = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPRender = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPRender",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPRender,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPRender,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPRender,
    &Dtool_SequenceMethods_BSPRender,
    &Dtool_MappingMethods_BSPRender,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPRender,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Top of the scene graph when a BSP level is in effect.\n"
    " * Culls nodes against the PVS, operates ambient cubes, etc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPRender,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPRender,
    PyType_GenericAlloc,
    Dtool_new_BSPRender,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPRender,
  Dtool_UpcastInterface_BSPRender,
  Dtool_DowncastInterface_BSPRender,
  (CoerceFunction)Dtool_ConstCoerce_BSPRender,
  (CoerceFunction)Dtool_Coerce_BSPRender,
};

static void Dtool_PyModuleClassInit_BSPRender(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPRender._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_BSPRender._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPRender) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPRender)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPRender);
  }
}

/**
 * Python method tables for BSPRoot (BSPRoot)
 */
static PyMethodDef Dtool_Methods_BSPRoot[] = {
  {"get_class_type", &Dtool_BSPRoot_get_class_type_175, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRoot_get_class_type_175_comment},
  {"getClassType", &Dtool_BSPRoot_get_class_type_175, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPRoot_get_class_type_175_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPRoot = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPRoot = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPRoot = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPRoot",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPRoot,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPRoot,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPRoot,
    &Dtool_SequenceMethods_BSPRoot,
    &Dtool_MappingMethods_BSPRoot,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPRoot,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPRoot,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPRoot,
    PyType_GenericAlloc,
    Dtool_new_BSPRoot,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPRoot,
  Dtool_UpcastInterface_BSPRoot,
  Dtool_DowncastInterface_BSPRoot,
  (CoerceFunction)Dtool_ConstCoerce_BSPRoot,
  (CoerceFunction)Dtool_Coerce_BSPRoot,
};

static void Dtool_PyModuleClassInit_BSPRoot(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPRoot._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_BSPRoot._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPRoot) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPRoot)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPRoot);
  }
}

/**
 * Python method tables for BSPProp (BSPProp)
 */
static PyMethodDef Dtool_Methods_BSPProp[] = {
  {"get_class_type", &Dtool_BSPProp_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPProp_get_class_type_180_comment},
  {"getClassType", &Dtool_BSPProp_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPProp_get_class_type_180_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPProp = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPProp = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPProp = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPProp",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPProp,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPProp,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPProp,
    &Dtool_SequenceMethods_BSPProp,
    &Dtool_MappingMethods_BSPProp,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPProp,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPProp,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPProp,
    PyType_GenericAlloc,
    Dtool_new_BSPProp,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPProp,
  Dtool_UpcastInterface_BSPProp,
  Dtool_DowncastInterface_BSPProp,
  (CoerceFunction)Dtool_ConstCoerce_BSPProp,
  (CoerceFunction)Dtool_Coerce_BSPProp,
};

static void Dtool_PyModuleClassInit_BSPProp(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelNode != nullptr);
    assert(Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPProp._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelNode);
    PyObject *dict = PyDict_New();
    Dtool_BSPProp._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPProp) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPProp)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPProp);
  }
}

/**
 * Python method tables for BSPModel (BSPModel)
 */
static PyMethodDef Dtool_Methods_BSPModel[] = {
  {"get_class_type", &Dtool_BSPModel_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPModel_get_class_type_184_comment},
  {"getClassType", &Dtool_BSPModel_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_BSPModel_get_class_type_184_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BSPModel = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BSPModel = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BSPModel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.BSPModel",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_BSPModel,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BSPModel,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BSPModel,
    &Dtool_SequenceMethods_BSPModel,
    &Dtool_MappingMethods_BSPModel,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BSPModel,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BSPModel,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BSPModel,
    PyType_GenericAlloc,
    Dtool_new_BSPModel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BSPModel,
  Dtool_UpcastInterface_BSPModel,
  Dtool_DowncastInterface_BSPModel,
  (CoerceFunction)Dtool_ConstCoerce_BSPModel,
  (CoerceFunction)Dtool_Coerce_BSPModel,
};

static void Dtool_PyModuleClassInit_BSPModel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelNode != nullptr);
    assert(Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ModelNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_BSPModel._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelNode);
    PyObject *dict = PyDict_New();
    Dtool_BSPModel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BSPModel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BSPModel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BSPModel);
  }
}

/**
 * Python method tables for ShaderPermutations (ShaderPermutations)
 */
static PyMethodDef Dtool_Methods_ShaderPermutations[] = {
  {"add_permutation", (PyCFunction) &Dtool_ShaderPermutations_add_permutation_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_permutation_188_comment},
  {"addPermutation", (PyCFunction) &Dtool_ShaderPermutations_add_permutation_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_permutation_188_comment},
  {"add_input", (PyCFunction) &Dtool_ShaderPermutations_add_input_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_input_189_comment},
  {"addInput", (PyCFunction) &Dtool_ShaderPermutations_add_input_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderPermutations_add_input_189_comment},
  {"add_flag", &Dtool_ShaderPermutations_add_flag_190, METH_O, (const char *)Dtool_ShaderPermutations_add_flag_190_comment},
  {"addFlag", &Dtool_ShaderPermutations_add_flag_190, METH_O, (const char *)Dtool_ShaderPermutations_add_flag_190_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A rich comparison function
//     ShaderPermutations
//////////////////
static PyObject *Dtool_RichCompare_ShaderPermutations(PyObject *self, PyObject *arg, int op) {
  ShaderPermutations *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShaderPermutations, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-bool ShaderPermutations::operator <(ShaderPermutations const &other) const
      ShaderPermutations const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ShaderPermutations);
      if (arg_this != nullptr) {
        bool return_value = (*(const ShaderPermutations*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_ShaderPermutations = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ShaderPermutations = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.ShaderPermutations",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderPermutations,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderPermutations,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a list of #defines and variable inputs to a shader that is being generated.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ShaderPermutations,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderPermutations,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderPermutations,
    PyType_GenericAlloc,
    Dtool_new_ShaderPermutations,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderPermutations,
  Dtool_UpcastInterface_ShaderPermutations,
  Dtool_DowncastInterface_ShaderPermutations,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShaderPermutations(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ShaderPermutations._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShaderPermutations._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderPermutations) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderPermutations)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderPermutations);
  }
}

/**
 * Python method tables for ShaderSpec (ShaderSpec)
 */
static PyMethodDef Dtool_Methods_ShaderSpec[] = {
  {"read_shader_files", (PyCFunction) &Dtool_ShaderSpec_read_shader_files_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderSpec_read_shader_files_201_comment},
  {"readShaderFiles", (PyCFunction) &Dtool_ShaderSpec_read_shader_files_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ShaderSpec_read_shader_files_201_comment},
  {"get_class_type", &Dtool_ShaderSpec_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderSpec_get_class_type_202_comment},
  {"getClassType", &Dtool_ShaderSpec_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShaderSpec_get_class_type_202_comment},
  {"upcast_to_ReferenceCount", &Dtool_ShaderSpec_upcast_to_ReferenceCount_196, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_ReferenceCount_196_comment},
  {"upcastToReferenceCount", &Dtool_ShaderSpec_upcast_to_ReferenceCount_196, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_ReferenceCount_196_comment},
  {"upcast_to_Namable", &Dtool_ShaderSpec_upcast_to_Namable_199, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_Namable_199_comment},
  {"upcastToNamable", &Dtool_ShaderSpec_upcast_to_Namable_199, METH_NOARGS, (const char *)Dtool_ShaderSpec_upcast_to_Namable_199_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShaderSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShaderSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShaderSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.ShaderSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShaderSpec,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShaderSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShaderSpec,
    &Dtool_SequenceMethods_ShaderSpec,
    &Dtool_MappingMethods_ShaderSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShaderSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Serves to setup the permutations for a specific shader\n"
    " * when setting up a shader for a specific RenderState.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShaderSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShaderSpec,
    PyType_GenericAlloc,
    Dtool_new_ShaderSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShaderSpec,
  Dtool_UpcastInterface_ShaderSpec,
  Dtool_DowncastInterface_ShaderSpec,
  (CoerceFunction)Dtool_ConstCoerce_ShaderSpec,
  (CoerceFunction)Dtool_Coerce_ShaderSpec,
};

static void Dtool_PyModuleClassInit_ShaderSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_ShaderSpec._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_ShaderSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShaderSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShaderSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShaderSpec);
  }
}

/**
 * Python method tables for PSSMShaderGenerator (PSSMShaderGenerator)
 */
static PyMethodDef Dtool_Methods_PSSMShaderGenerator[] = {
  {"set_sun_light", &Dtool_PSSMShaderGenerator_set_sun_light_207, METH_O, (const char *)Dtool_PSSMShaderGenerator_set_sun_light_207_comment},
  {"setSunLight", &Dtool_PSSMShaderGenerator_set_sun_light_207, METH_O, (const char *)Dtool_PSSMShaderGenerator_set_sun_light_207_comment},
  {"start_update", &Dtool_PSSMShaderGenerator_start_update_208, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_start_update_208_comment},
  {"startUpdate", &Dtool_PSSMShaderGenerator_start_update_208, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_start_update_208_comment},
  {"add_shader", &Dtool_PSSMShaderGenerator_add_shader_209, METH_O, (const char *)Dtool_PSSMShaderGenerator_add_shader_209_comment},
  {"addShader", &Dtool_PSSMShaderGenerator_add_shader_209, METH_O, (const char *)Dtool_PSSMShaderGenerator_add_shader_209_comment},
  {"has_shadow_sunlight", &Dtool_PSSMShaderGenerator_has_shadow_sunlight_210, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_has_shadow_sunlight_210_comment},
  {"hasShadowSunlight", &Dtool_PSSMShaderGenerator_has_shadow_sunlight_210, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_has_shadow_sunlight_210_comment},
  {"get_pssm_array_texture", &Dtool_PSSMShaderGenerator_get_pssm_array_texture_211, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_get_pssm_array_texture_211_comment},
  {"getPssmArrayTexture", &Dtool_PSSMShaderGenerator_get_pssm_array_texture_211, METH_NOARGS, (const char *)Dtool_PSSMShaderGenerator_get_pssm_array_texture_211_comment},
  {"get_identity_cubemap", &Dtool_PSSMShaderGenerator_get_identity_cubemap_213, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSSMShaderGenerator_get_identity_cubemap_213_comment},
  {"getIdentityCubemap", &Dtool_PSSMShaderGenerator_get_identity_cubemap_213, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSSMShaderGenerator_get_identity_cubemap_213_comment},
  {"get_class_type", &Dtool_PSSMShaderGenerator_get_class_type_214, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSSMShaderGenerator_get_class_type_214_comment},
  {"getClassType", &Dtool_PSSMShaderGenerator_get_class_type_214, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSSMShaderGenerator_get_class_type_214_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PSSMShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PSSMShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PSSMShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PSSMShaderGenerator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PSSMShaderGenerator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PSSMShaderGenerator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.PSSMShaderGenerator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PSSMShaderGenerator,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PSSMShaderGenerator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PSSMShaderGenerator,
    &Dtool_SequenceMethods_PSSMShaderGenerator,
    &Dtool_MappingMethods_PSSMShaderGenerator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PSSMShaderGenerator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PSSMShaderGenerator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PSSMShaderGenerator,
    PyType_GenericAlloc,
    Dtool_new_PSSMShaderGenerator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PSSMShaderGenerator,
  Dtool_UpcastInterface_PSSMShaderGenerator,
  Dtool_DowncastInterface_PSSMShaderGenerator,
  (CoerceFunction)Dtool_ConstCoerce_PSSMShaderGenerator,
  (CoerceFunction)Dtool_Coerce_PSSMShaderGenerator,
};

static void Dtool_PyModuleClassInit_PSSMShaderGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ShaderGenerator != nullptr);
    assert(Dtool_Ptr_ShaderGenerator->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ShaderGenerator->_Dtool_ModuleClassInit(nullptr);
    Dtool_PSSMShaderGenerator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ShaderGenerator);
    PyObject *dict = PyDict_New();
    Dtool_PSSMShaderGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PSSMShaderGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PSSMShaderGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PSSMShaderGenerator);
  }
}

/**
 * Python method tables for VertexLitGenericSpec (VertexLitGenericSpec)
 */
static PyMethodDef Dtool_Methods_VertexLitGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VertexLitGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VertexLitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VertexLitGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.VertexLitGenericSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VertexLitGenericSpec,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VertexLitGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VertexLitGenericSpec,
    &Dtool_SequenceMethods_VertexLitGenericSpec,
    &Dtool_MappingMethods_VertexLitGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VertexLitGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VertexLitGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VertexLitGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_VertexLitGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VertexLitGenericSpec,
  Dtool_UpcastInterface_VertexLitGenericSpec,
  Dtool_DowncastInterface_VertexLitGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VertexLitGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_VertexLitGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    PyObject *dict = PyDict_New();
    Dtool_VertexLitGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VertexLitGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VertexLitGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VertexLitGenericSpec);
  }
}

/**
 * Python method tables for LightmappedGenericSpec (LightmappedGenericSpec)
 */
static PyMethodDef Dtool_Methods_LightmappedGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LightmappedGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LightmappedGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LightmappedGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.LightmappedGenericSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LightmappedGenericSpec,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LightmappedGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LightmappedGenericSpec,
    &Dtool_SequenceMethods_LightmappedGenericSpec,
    &Dtool_MappingMethods_LightmappedGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LightmappedGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LightmappedGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LightmappedGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_LightmappedGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LightmappedGenericSpec,
  Dtool_UpcastInterface_LightmappedGenericSpec,
  Dtool_DowncastInterface_LightmappedGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LightmappedGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_LightmappedGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    PyObject *dict = PyDict_New();
    Dtool_LightmappedGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LightmappedGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LightmappedGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LightmappedGenericSpec);
  }
}

/**
 * Python method tables for UnlitGenericSpec (UnlitGenericSpec)
 */
static PyMethodDef Dtool_Methods_UnlitGenericSpec[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UnlitGenericSpec = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UnlitGenericSpec = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UnlitGenericSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "bsp.UnlitGenericSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnlitGenericSpec,
    nullptr,
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UnlitGenericSpec,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UnlitGenericSpec,
    &Dtool_SequenceMethods_UnlitGenericSpec,
    &Dtool_MappingMethods_UnlitGenericSpec,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UnlitGenericSpec,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Shader that only supports a basetexture, no fancy lighting effects or anything.\n"
    " * Could be used for UI elements, emissive materials, particles, etc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UnlitGenericSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UnlitGenericSpec,
    PyType_GenericAlloc,
    Dtool_new_UnlitGenericSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnlitGenericSpec,
  Dtool_UpcastInterface_UnlitGenericSpec,
  Dtool_DowncastInterface_UnlitGenericSpec,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UnlitGenericSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ShaderSpec(nullptr);
    Dtool_UnlitGenericSpec._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ShaderSpec);
    PyObject *dict = PyDict_New();
    Dtool_UnlitGenericSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UnlitGenericSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnlitGenericSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnlitGenericSpec);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_bsp_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    BSPMaterial::init_type();
    TypeHandle handle = BSPMaterial::get_class_type();
    Dtool_BSPMaterial._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPMaterial);
  }
  {
    BSPMaterialAttrib::init_type();
    TypeHandle handle = BSPMaterialAttrib::get_class_type();
    Dtool_BSPMaterialAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPMaterialAttrib);
  }
  {
    CBaseEntity::init_type();
    TypeHandle handle = CBaseEntity::get_class_type();
    Dtool_CBaseEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBaseEntity);
  }
  {
    CPointEntity::init_type();
    TypeHandle handle = CPointEntity::get_class_type();
    Dtool_CPointEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CPointEntity);
  }
  {
    CBoundsEntity::init_type();
    TypeHandle handle = CBoundsEntity::get_class_type();
    Dtool_CBoundsEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBoundsEntity);
  }
  {
    CBrushEntity::init_type();
    TypeHandle handle = CBrushEntity::get_class_type();
    Dtool_CBrushEntity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CBrushEntity);
  }
  {
    BSPFaceAttrib::init_type();
    TypeHandle handle = BSPFaceAttrib::get_class_type();
    Dtool_BSPFaceAttrib._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPFaceAttrib);
  }
  {
    BSPCullTraverser::init_type();
    TypeHandle handle = BSPCullTraverser::get_class_type();
    Dtool_BSPCullTraverser._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPCullTraverser);
  }
  {
    BSPRender::init_type();
    TypeHandle handle = BSPRender::get_class_type();
    Dtool_BSPRender._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPRender);
  }
  {
    BSPRoot::init_type();
    TypeHandle handle = BSPRoot::get_class_type();
    Dtool_BSPRoot._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPRoot);
  }
  {
    BSPProp::init_type();
    TypeHandle handle = BSPProp::get_class_type();
    Dtool_BSPProp._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPProp);
  }
  {
    BSPModel::init_type();
    TypeHandle handle = BSPModel::get_class_type();
    Dtool_BSPModel._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BSPModel);
  }
  {
    ShaderSpec::init_type();
    TypeHandle handle = ShaderSpec::get_class_type();
    Dtool_ShaderSpec._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShaderSpec);
  }
  {
    PSSMShaderGenerator::init_type();
    TypeHandle handle = PSSMShaderGenerator::get_class_type();
    Dtool_PSSMShaderGenerator._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PSSMShaderGenerator);
  }
}

void Dtool_bsp_BuildInstants(PyObject *module) {
  (void) module;
  // TextureStages
  Dtool_PyModuleClassInit_TextureStages(module);
  PyModule_AddObject(module, "TextureStages", (PyObject *)&Dtool_TextureStages);
  // BSPMaterial
  Dtool_PyModuleClassInit_BSPMaterial(module);
  PyModule_AddObject(module, "BSPMaterial", (PyObject *)&Dtool_BSPMaterial);
  // BSPMaterialAttrib
  Dtool_PyModuleClassInit_BSPMaterialAttrib(module);
  PyModule_AddObject(module, "BSPMaterialAttrib", (PyObject *)&Dtool_BSPMaterialAttrib);
  // CBaseEntity
  Dtool_PyModuleClassInit_CBaseEntity(module);
  PyModule_AddObject(module, "CBaseEntity", (PyObject *)&Dtool_CBaseEntity);
  // CPointEntity
  Dtool_PyModuleClassInit_CPointEntity(module);
  PyModule_AddObject(module, "CPointEntity", (PyObject *)&Dtool_CPointEntity);
  // CBoundsEntity
  Dtool_PyModuleClassInit_CBoundsEntity(module);
  PyModule_AddObject(module, "CBoundsEntity", (PyObject *)&Dtool_CBoundsEntity);
  // CBrushEntity
  Dtool_PyModuleClassInit_CBrushEntity(module);
  PyModule_AddObject(module, "CBrushEntity", (PyObject *)&Dtool_CBrushEntity);
  // PackResult
  Dtool_PyModuleClassInit_PackResult(module);
  PyModule_AddObject(module, "PackResult", (PyObject *)&Dtool_PackResult);
  // TextureLocation
  Dtool_PyModuleClassInit_TextureLocation(module);
  PyModule_AddObject(module, "TextureLocation", (PyObject *)&Dtool_TextureLocation);
  // TexturePacker
  Dtool_PyModuleClassInit_TexturePacker(module);
  PyModule_AddObject(module, "TexturePacker", (PyObject *)&Dtool_TexturePacker);
  // BSPFaceAttrib
  Dtool_PyModuleClassInit_BSPFaceAttrib(module);
  PyModule_AddObject(module, "BSPFaceAttrib", (PyObject *)&Dtool_BSPFaceAttrib);
  // BSPLoader
  Dtool_PyModuleClassInit_BSPLoader(module);
  PyModule_AddObject(module, "BSPLoader", (PyObject *)&Dtool_BSPLoader);
  // BSPCullTraverser
  Dtool_PyModuleClassInit_BSPCullTraverser(module);
  PyModule_AddObject(module, "BSPCullTraverser", (PyObject *)&Dtool_BSPCullTraverser);
  // BSPRender
  Dtool_PyModuleClassInit_BSPRender(module);
  PyModule_AddObject(module, "BSPRender", (PyObject *)&Dtool_BSPRender);
  // BSPRoot
  Dtool_PyModuleClassInit_BSPRoot(module);
  PyModule_AddObject(module, "BSPRoot", (PyObject *)&Dtool_BSPRoot);
  // BSPProp
  Dtool_PyModuleClassInit_BSPProp(module);
  PyModule_AddObject(module, "BSPProp", (PyObject *)&Dtool_BSPProp);
  // BSPModel
  Dtool_PyModuleClassInit_BSPModel(module);
  PyModule_AddObject(module, "BSPModel", (PyObject *)&Dtool_BSPModel);
  // ShaderPermutations
  Dtool_PyModuleClassInit_ShaderPermutations(module);
  PyModule_AddObject(module, "ShaderPermutations", (PyObject *)&Dtool_ShaderPermutations);
  // ShaderSpec
  Dtool_PyModuleClassInit_ShaderSpec(module);
  PyModule_AddObject(module, "ShaderSpec", (PyObject *)&Dtool_ShaderSpec);
  // PSSMShaderGenerator
  Dtool_PyModuleClassInit_PSSMShaderGenerator(module);
  PyModule_AddObject(module, "PSSMShaderGenerator", (PyObject *)&Dtool_PSSMShaderGenerator);
  // VertexLitGenericSpec
  Dtool_PyModuleClassInit_VertexLitGenericSpec(module);
  PyModule_AddObject(module, "VertexLitGenericSpec", (PyObject *)&Dtool_VertexLitGenericSpec);
  // LightmappedGenericSpec
  Dtool_PyModuleClassInit_LightmappedGenericSpec(module);
  PyModule_AddObject(module, "LightmappedGenericSpec", (PyObject *)&Dtool_LightmappedGenericSpec);
  // UnlitGenericSpec
  Dtool_PyModuleClassInit_UnlitGenericSpec(module);
  PyModule_AddObject(module, "UnlitGenericSpec", (PyObject *)&Dtool_UnlitGenericSpec);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef bsp_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef bsp_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1547069653,  /* file_identifier */
  "bsp",  /* library_name */
  "t5GT",  /* library_hash_name */
  "bsp",  /* module_name */
  "bsp.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  526  /* next_index */
};

Configure(_in_configure_bsp);
ConfigureFn(_in_configure_bsp) {
  interrogate_request_module(&_in_module_def);
}

